Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement DOT
Rule 3     program_heading -> PROGRAM identifier SEMICOLON
Rule 4     block -> variable_declaration_part BEGIN statement_list END SEMICOLON
Rule 5     type_definition_part -> TYPE type_definition_list
Rule 6     type_definition_part -> empty
Rule 7     type_definition_list -> type_definition
Rule 8     type_definition_list -> type_definition type_definition_list
Rule 9     variable_declaration_part -> VAR variable_declaration_list
Rule 10    variable_declaration_part -> empty
Rule 11    function_declaration_part -> function_declaration function_declaration_part
Rule 12    function_declaration_part -> empty
Rule 13    function_declaration -> function_heading SEMICOLON block
Rule 14    function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name
Rule 15    parameters -> names_list COLON simple_type_name
Rule 16    parameters -> names_list COLON simple_type_name SEMICOLON parameters
Rule 17    names_list -> identifier
Rule 18    names_list -> identifier COMMA names_list
Rule 19    type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
Rule 20    statement_list -> statement_part statement_list
Rule 21    statement_list -> empty
Rule 22    statement_part -> compound_statement
Rule 23    statement_part -> assignment_list
Rule 24    statement_part -> while_statement
Rule 25    statement_part -> if_else_statement
Rule 26    statement_part -> expression
Rule 27    statement_part -> empty
Rule 28    while_statement -> WHILE expression DO statement_part SEMICOLON
Rule 29    if_else_statement -> IF expression THEN statement_list SEMICOLON
Rule 30    if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON
Rule 31    compound_statement -> BEGIN statement_list END ending
Rule 32    assignment_list -> assignment statement_list
Rule 33    assignment -> identifier ASSIGNMENT expression ending
Rule 34    assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
Rule 35    ending -> SEMICOLON
Rule 36    ending -> empty
Rule 37    expression -> term
Rule 38    expression -> expression sign term
Rule 39    expression -> expression and_or expression
Rule 40    and_or -> AND
Rule 41    and_or -> OR
Rule 42    sign -> PLUS
Rule 43    sign -> MINUS
Rule 44    sign -> EQ
Rule 45    sign -> NEQ
Rule 46    sign -> GT
Rule 47    sign -> LT
Rule 48    sign -> GTE
Rule 49    sign -> LTE
Rule 50    term -> integer
Rule 51    term -> real
Rule 52    term -> char
Rule 53    term -> string
Rule 54    term -> function_call
Rule 55    term -> identifier
Rule 56    integer -> INTEGER
Rule 57    real -> REAL
Rule 58    string -> STRING
Rule 59    char -> CHAR
Rule 60    function_call -> identifier LPAREN identifier_list RPAREN
Rule 61    variable_declaration_list -> variable_declaration
Rule 62    variable_declaration_list -> variable_declaration variable_declaration_list
Rule 63    variable_declaration -> identifier_list COLON simple_type_name SEMICOLON
Rule 64    variable_declaration -> identifier COLON simple_type_name SEMICOLON
Rule 65    variable_declaration -> identifier COLON identifier SEMICOLON
Rule 66    variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
Rule 67    identifier_list -> identifier COMMA identifier_list
Rule 68    identifier_list -> identifier COMMA identifier
Rule 69    identifier_list -> empty
Rule 70    simple_type_name -> SSTRING
Rule 71    simple_type_name -> SCHAR
Rule 72    simple_type_name -> SREAL
Rule 73    simple_type_name -> SINTEGER
Rule 74    simple_type_name -> identifier
Rule 75    identifier -> IDENTIFIER

Terminals, with rules where they appear

AND                  : 40
ARRAY                : 19 66
ASSIGNMENT           : 33 34
BEGIN                : 4 31
CHAR                 : 59
COLON                : 14 15 16 63 64 65 66
COMMA                : 18 67 68
DD                   : 19 66
DO                   : 28
DOT                  : 2
ELSE                 : 30
END                  : 4 31
EQ                   : 19 44
FUNCTION             : 14
GT                   : 46
GTE                  : 48
IDENTIFIER           : 75
IF                   : 29 30
INTEGER              : 19 19 56 66 66
LPAREN               : 14 60
LPARENARR            : 19 34 66
LT                   : 47
LTE                  : 49
MINUS                : 43
NEQ                  : 45
OF                   : 19 66
OR                   : 41
PLUS                 : 42
PROGRAM              : 3
REAL                 : 57
RPAREN               : 14 60
RPARENARR            : 19 34 66
SCHAR                : 71
SEMICOLON            : 3 4 13 16 19 28 29 30 35 63 64 65 66
SINTEGER             : 73
SREAL                : 72
SSTRING              : 70
STRING               : 58
THEN                 : 29 30
TYPE                 : 5
VAR                  : 9
WHILE                : 28
error                : 

Nonterminals, with rules where they appear

and_or               : 39
assignment           : 32
assignment_list      : 23
block                : 13
char                 : 52
compound_statement   : 2 22
empty                : 6 10 12 21 27 36 69
ending               : 31 33 34
expression           : 26 28 29 30 33 34 38 39 39
function_call        : 54
function_declaration : 11
function_declaration_part : 2 11
function_heading     : 13
identifier           : 3 14 17 18 19 33 34 55 60 64 65 65 66 67 68 68 74
identifier_list      : 60 63 67
if_else_statement    : 25
integer              : 50
names_list           : 15 16 18
parameters           : 14 16
program              : 0
program_heading      : 2
real                 : 51
sign                 : 38
simple_type_name     : 14 15 16 19 63 64 66
statement_list       : 4 20 29 30 30 31 32
statement_part       : 20 28
string               : 53
term                 : 34 37 38
type_definition      : 7 8
type_definition_list : 5 8
type_definition_part : 2
variable_declaration : 61 62
variable_declaration_list : 9 62
variable_declaration_part : 2 4
while_statement      : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement DOT
    (3) program_heading -> . PROGRAM identifier SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (2) program -> program_heading . type_definition_part variable_declaration_part function_declaration_part compound_statement DOT
    (5) type_definition_part -> . TYPE type_definition_list
    (6) type_definition_part -> . empty
    (1) empty -> .

    TYPE            shift and go to state 5
    VAR             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    type_definition_part           shift and go to state 4
    empty                          shift and go to state 6

state 3

    (3) program_heading -> PROGRAM . identifier SEMICOLON
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 7

state 4

    (2) program -> program_heading type_definition_part . variable_declaration_part function_declaration_part compound_statement DOT
    (9) variable_declaration_part -> . VAR variable_declaration_list
    (10) variable_declaration_part -> . empty
    (1) empty -> .

    VAR             shift and go to state 10
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    variable_declaration_part      shift and go to state 9
    empty                          shift and go to state 11

state 5

    (5) type_definition_part -> TYPE . type_definition_list
    (7) type_definition_list -> . type_definition
    (8) type_definition_list -> . type_definition type_definition_list
    (19) type_definition -> . identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    type_definition_list           shift and go to state 12
    type_definition                shift and go to state 13
    identifier                     shift and go to state 14

state 6

    (6) type_definition_part -> empty .

    VAR             reduce using rule 6 (type_definition_part -> empty .)
    FUNCTION        reduce using rule 6 (type_definition_part -> empty .)
    BEGIN           reduce using rule 6 (type_definition_part -> empty .)


state 7

    (3) program_heading -> PROGRAM identifier . SEMICOLON

    SEMICOLON       shift and go to state 15


state 8

    (75) identifier -> IDENTIFIER .

    SEMICOLON       reduce using rule 75 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 75 (identifier -> IDENTIFIER .)
    COLON           reduce using rule 75 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 75 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 75 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 75 (identifier -> IDENTIFIER .)
    LPARENARR       reduce using rule 75 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 75 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 75 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 75 (identifier -> IDENTIFIER .)
    GT              reduce using rule 75 (identifier -> IDENTIFIER .)
    LT              reduce using rule 75 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 75 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 75 (identifier -> IDENTIFIER .)
    AND             reduce using rule 75 (identifier -> IDENTIFIER .)
    OR              reduce using rule 75 (identifier -> IDENTIFIER .)
    BEGIN           reduce using rule 75 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 75 (identifier -> IDENTIFIER .)
    IF              reduce using rule 75 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 75 (identifier -> IDENTIFIER .)
    INTEGER         reduce using rule 75 (identifier -> IDENTIFIER .)
    REAL            reduce using rule 75 (identifier -> IDENTIFIER .)
    CHAR            reduce using rule 75 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 75 (identifier -> IDENTIFIER .)
    END             reduce using rule 75 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 75 (identifier -> IDENTIFIER .)
    DO              reduce using rule 75 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 75 (identifier -> IDENTIFIER .)
    RPARENARR       reduce using rule 75 (identifier -> IDENTIFIER .)


state 9

    (2) program -> program_heading type_definition_part variable_declaration_part . function_declaration_part compound_statement DOT
    (11) function_declaration_part -> . function_declaration function_declaration_part
    (12) function_declaration_part -> . empty
    (13) function_declaration -> . function_heading SEMICOLON block
    (1) empty -> .
    (14) function_heading -> . FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name

    BEGIN           reduce using rule 1 (empty -> .)
    FUNCTION        shift and go to state 20

    function_declaration_part      shift and go to state 16
    function_declaration           shift and go to state 17
    empty                          shift and go to state 18
    function_heading               shift and go to state 19

state 10

    (9) variable_declaration_part -> VAR . variable_declaration_list
    (61) variable_declaration_list -> . variable_declaration
    (62) variable_declaration_list -> . variable_declaration variable_declaration_list
    (63) variable_declaration -> . identifier_list COLON simple_type_name SEMICOLON
    (64) variable_declaration -> . identifier COLON simple_type_name SEMICOLON
    (65) variable_declaration -> . identifier COLON identifier SEMICOLON
    (66) variable_declaration -> . identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    IDENTIFIER      shift and go to state 8
    COLON           reduce using rule 1 (empty -> .)

    variable_declaration_list      shift and go to state 21
    variable_declaration           shift and go to state 22
    identifier_list                shift and go to state 23
    identifier                     shift and go to state 24
    empty                          shift and go to state 25

state 11

    (10) variable_declaration_part -> empty .

    FUNCTION        reduce using rule 10 (variable_declaration_part -> empty .)
    BEGIN           reduce using rule 10 (variable_declaration_part -> empty .)


state 12

    (5) type_definition_part -> TYPE type_definition_list .

    VAR             reduce using rule 5 (type_definition_part -> TYPE type_definition_list .)
    FUNCTION        reduce using rule 5 (type_definition_part -> TYPE type_definition_list .)
    BEGIN           reduce using rule 5 (type_definition_part -> TYPE type_definition_list .)


state 13

    (7) type_definition_list -> type_definition .
    (8) type_definition_list -> type_definition . type_definition_list
    (7) type_definition_list -> . type_definition
    (8) type_definition_list -> . type_definition type_definition_list
    (19) type_definition -> . identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (75) identifier -> . IDENTIFIER

    VAR             reduce using rule 7 (type_definition_list -> type_definition .)
    FUNCTION        reduce using rule 7 (type_definition_list -> type_definition .)
    BEGIN           reduce using rule 7 (type_definition_list -> type_definition .)
    IDENTIFIER      shift and go to state 8

    type_definition                shift and go to state 13
    type_definition_list           shift and go to state 26
    identifier                     shift and go to state 14

state 14

    (19) type_definition -> identifier . EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    EQ              shift and go to state 27


state 15

    (3) program_heading -> PROGRAM identifier SEMICOLON .

    TYPE            reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)
    VAR             reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)
    FUNCTION        reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)
    BEGIN           reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)


state 16

    (2) program -> program_heading type_definition_part variable_declaration_part function_declaration_part . compound_statement DOT
    (31) compound_statement -> . BEGIN statement_list END ending

    BEGIN           shift and go to state 29

    compound_statement             shift and go to state 28

state 17

    (11) function_declaration_part -> function_declaration . function_declaration_part
    (11) function_declaration_part -> . function_declaration function_declaration_part
    (12) function_declaration_part -> . empty
    (13) function_declaration -> . function_heading SEMICOLON block
    (1) empty -> .
    (14) function_heading -> . FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name

    BEGIN           reduce using rule 1 (empty -> .)
    FUNCTION        shift and go to state 20

    function_declaration           shift and go to state 17
    function_declaration_part      shift and go to state 30
    empty                          shift and go to state 18
    function_heading               shift and go to state 19

state 18

    (12) function_declaration_part -> empty .

    BEGIN           reduce using rule 12 (function_declaration_part -> empty .)


state 19

    (13) function_declaration -> function_heading . SEMICOLON block

    SEMICOLON       shift and go to state 31


state 20

    (14) function_heading -> FUNCTION . identifier LPAREN parameters RPAREN COLON simple_type_name
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 32

state 21

    (9) variable_declaration_part -> VAR variable_declaration_list .

    FUNCTION        reduce using rule 9 (variable_declaration_part -> VAR variable_declaration_list .)
    BEGIN           reduce using rule 9 (variable_declaration_part -> VAR variable_declaration_list .)


state 22

    (61) variable_declaration_list -> variable_declaration .
    (62) variable_declaration_list -> variable_declaration . variable_declaration_list
    (61) variable_declaration_list -> . variable_declaration
    (62) variable_declaration_list -> . variable_declaration variable_declaration_list
    (63) variable_declaration -> . identifier_list COLON simple_type_name SEMICOLON
    (64) variable_declaration -> . identifier COLON simple_type_name SEMICOLON
    (65) variable_declaration -> . identifier COLON identifier SEMICOLON
    (66) variable_declaration -> . identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    FUNCTION        reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    BEGIN           reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    IDENTIFIER      shift and go to state 8
    COLON           reduce using rule 1 (empty -> .)

    variable_declaration           shift and go to state 22
    variable_declaration_list      shift and go to state 33
    identifier_list                shift and go to state 23
    identifier                     shift and go to state 24
    empty                          shift and go to state 25

state 23

    (63) variable_declaration -> identifier_list . COLON simple_type_name SEMICOLON

    COLON           shift and go to state 34


state 24

    (64) variable_declaration -> identifier . COLON simple_type_name SEMICOLON
    (65) variable_declaration -> identifier . COLON identifier SEMICOLON
    (66) variable_declaration -> identifier . COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (67) identifier_list -> identifier . COMMA identifier_list
    (68) identifier_list -> identifier . COMMA identifier

    COLON           shift and go to state 35
    COMMA           shift and go to state 36


state 25

    (69) identifier_list -> empty .

    COLON           reduce using rule 69 (identifier_list -> empty .)
    RPAREN          reduce using rule 69 (identifier_list -> empty .)


state 26

    (8) type_definition_list -> type_definition type_definition_list .

    VAR             reduce using rule 8 (type_definition_list -> type_definition type_definition_list .)
    FUNCTION        reduce using rule 8 (type_definition_list -> type_definition type_definition_list .)
    BEGIN           reduce using rule 8 (type_definition_list -> type_definition type_definition_list .)


state 27

    (19) type_definition -> identifier EQ . ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    ARRAY           shift and go to state 37


state 28

    (2) program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement . DOT

    DOT             shift and go to state 38


state 29

    (31) compound_statement -> BEGIN . statement_list END ending
    (20) statement_list -> . statement_part statement_list
    (21) statement_list -> . empty
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (1) empty -> .
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    END             reduce using rule 1 (empty -> .)
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    statement_list                 shift and go to state 39
    statement_part                 shift and go to state 40
    empty                          shift and go to state 41
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    expression                     shift and go to state 46
    assignment                     shift and go to state 47
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 30

    (11) function_declaration_part -> function_declaration function_declaration_part .

    BEGIN           reduce using rule 11 (function_declaration_part -> function_declaration function_declaration_part .)


state 31

    (13) function_declaration -> function_heading SEMICOLON . block
    (4) block -> . variable_declaration_part BEGIN statement_list END SEMICOLON
    (9) variable_declaration_part -> . VAR variable_declaration_list
    (10) variable_declaration_part -> . empty
    (1) empty -> .

    VAR             shift and go to state 10
    BEGIN           reduce using rule 1 (empty -> .)

    block                          shift and go to state 61
    variable_declaration_part      shift and go to state 62
    empty                          shift and go to state 11

state 32

    (14) function_heading -> FUNCTION identifier . LPAREN parameters RPAREN COLON simple_type_name

    LPAREN          shift and go to state 63


state 33

    (62) variable_declaration_list -> variable_declaration variable_declaration_list .

    FUNCTION        reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    BEGIN           reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 34

    (63) variable_declaration -> identifier_list COLON . simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 65
    SCHAR           shift and go to state 66
    SREAL           shift and go to state 67
    SINTEGER        shift and go to state 68
    IDENTIFIER      shift and go to state 8

    simple_type_name               shift and go to state 64
    identifier                     shift and go to state 69

state 35

    (64) variable_declaration -> identifier COLON . simple_type_name SEMICOLON
    (65) variable_declaration -> identifier COLON . identifier SEMICOLON
    (66) variable_declaration -> identifier COLON . ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    ARRAY           shift and go to state 72
    SSTRING         shift and go to state 65
    SCHAR           shift and go to state 66
    SREAL           shift and go to state 67
    SINTEGER        shift and go to state 68
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 70
    simple_type_name               shift and go to state 71

state 36

    (67) identifier_list -> identifier COMMA . identifier_list
    (68) identifier_list -> identifier COMMA . identifier
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    IDENTIFIER      shift and go to state 8
    COLON           reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 73
    identifier_list                shift and go to state 74
    empty                          shift and go to state 25

state 37

    (19) type_definition -> identifier EQ ARRAY . LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    LPARENARR       shift and go to state 75


state 38

    (2) program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement DOT .

    $end            reduce using rule 2 (program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement DOT .)


state 39

    (31) compound_statement -> BEGIN statement_list . END ending

    END             shift and go to state 76


state 40

    (20) statement_list -> statement_part . statement_list
    (20) statement_list -> . statement_part statement_list
    (21) statement_list -> . empty
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (1) empty -> .
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    END             reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    statement_part                 shift and go to state 40
    statement_list                 shift and go to state 77
    empty                          shift and go to state 41
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    expression                     shift and go to state 46
    assignment                     shift and go to state 47
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 41

    (21) statement_list -> empty .
    (27) statement_part -> empty .

  ! reduce/reduce conflict for BEGIN resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for REAL resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for CHAR resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for STRING resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for END resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (statement_list -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 21 (statement_list -> empty .)
    END             reduce using rule 21 (statement_list -> empty .)
    BEGIN           reduce using rule 21 (statement_list -> empty .)
    WHILE           reduce using rule 21 (statement_list -> empty .)
    IF              reduce using rule 21 (statement_list -> empty .)
    IDENTIFIER      reduce using rule 21 (statement_list -> empty .)
    INTEGER         reduce using rule 21 (statement_list -> empty .)
    REAL            reduce using rule 21 (statement_list -> empty .)
    CHAR            reduce using rule 21 (statement_list -> empty .)
    STRING          reduce using rule 21 (statement_list -> empty .)
    SEMICOLON       reduce using rule 21 (statement_list -> empty .)
    ELSE            reduce using rule 21 (statement_list -> empty .)

  ! BEGIN           [ reduce using rule 27 (statement_part -> empty .) ]
  ! WHILE           [ reduce using rule 27 (statement_part -> empty .) ]
  ! IF              [ reduce using rule 27 (statement_part -> empty .) ]
  ! IDENTIFIER      [ reduce using rule 27 (statement_part -> empty .) ]
  ! INTEGER         [ reduce using rule 27 (statement_part -> empty .) ]
  ! REAL            [ reduce using rule 27 (statement_part -> empty .) ]
  ! CHAR            [ reduce using rule 27 (statement_part -> empty .) ]
  ! STRING          [ reduce using rule 27 (statement_part -> empty .) ]
  ! END             [ reduce using rule 27 (statement_part -> empty .) ]
  ! SEMICOLON       [ reduce using rule 27 (statement_part -> empty .) ]
  ! ELSE            [ reduce using rule 27 (statement_part -> empty .) ]


state 42

    (22) statement_part -> compound_statement .

    BEGIN           reduce using rule 22 (statement_part -> compound_statement .)
    WHILE           reduce using rule 22 (statement_part -> compound_statement .)
    IF              reduce using rule 22 (statement_part -> compound_statement .)
    IDENTIFIER      reduce using rule 22 (statement_part -> compound_statement .)
    INTEGER         reduce using rule 22 (statement_part -> compound_statement .)
    REAL            reduce using rule 22 (statement_part -> compound_statement .)
    CHAR            reduce using rule 22 (statement_part -> compound_statement .)
    STRING          reduce using rule 22 (statement_part -> compound_statement .)
    END             reduce using rule 22 (statement_part -> compound_statement .)
    SEMICOLON       reduce using rule 22 (statement_part -> compound_statement .)
    ELSE            reduce using rule 22 (statement_part -> compound_statement .)


state 43

    (23) statement_part -> assignment_list .

    BEGIN           reduce using rule 23 (statement_part -> assignment_list .)
    WHILE           reduce using rule 23 (statement_part -> assignment_list .)
    IF              reduce using rule 23 (statement_part -> assignment_list .)
    IDENTIFIER      reduce using rule 23 (statement_part -> assignment_list .)
    INTEGER         reduce using rule 23 (statement_part -> assignment_list .)
    REAL            reduce using rule 23 (statement_part -> assignment_list .)
    CHAR            reduce using rule 23 (statement_part -> assignment_list .)
    STRING          reduce using rule 23 (statement_part -> assignment_list .)
    END             reduce using rule 23 (statement_part -> assignment_list .)
    SEMICOLON       reduce using rule 23 (statement_part -> assignment_list .)
    ELSE            reduce using rule 23 (statement_part -> assignment_list .)


state 44

    (24) statement_part -> while_statement .

    BEGIN           reduce using rule 24 (statement_part -> while_statement .)
    WHILE           reduce using rule 24 (statement_part -> while_statement .)
    IF              reduce using rule 24 (statement_part -> while_statement .)
    IDENTIFIER      reduce using rule 24 (statement_part -> while_statement .)
    INTEGER         reduce using rule 24 (statement_part -> while_statement .)
    REAL            reduce using rule 24 (statement_part -> while_statement .)
    CHAR            reduce using rule 24 (statement_part -> while_statement .)
    STRING          reduce using rule 24 (statement_part -> while_statement .)
    END             reduce using rule 24 (statement_part -> while_statement .)
    SEMICOLON       reduce using rule 24 (statement_part -> while_statement .)
    ELSE            reduce using rule 24 (statement_part -> while_statement .)


state 45

    (25) statement_part -> if_else_statement .

    BEGIN           reduce using rule 25 (statement_part -> if_else_statement .)
    WHILE           reduce using rule 25 (statement_part -> if_else_statement .)
    IF              reduce using rule 25 (statement_part -> if_else_statement .)
    IDENTIFIER      reduce using rule 25 (statement_part -> if_else_statement .)
    INTEGER         reduce using rule 25 (statement_part -> if_else_statement .)
    REAL            reduce using rule 25 (statement_part -> if_else_statement .)
    CHAR            reduce using rule 25 (statement_part -> if_else_statement .)
    STRING          reduce using rule 25 (statement_part -> if_else_statement .)
    END             reduce using rule 25 (statement_part -> if_else_statement .)
    SEMICOLON       reduce using rule 25 (statement_part -> if_else_statement .)
    ELSE            reduce using rule 25 (statement_part -> if_else_statement .)


state 46

    (26) statement_part -> expression .
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

    BEGIN           reduce using rule 26 (statement_part -> expression .)
    WHILE           reduce using rule 26 (statement_part -> expression .)
    IF              reduce using rule 26 (statement_part -> expression .)
    IDENTIFIER      reduce using rule 26 (statement_part -> expression .)
    INTEGER         reduce using rule 26 (statement_part -> expression .)
    REAL            reduce using rule 26 (statement_part -> expression .)
    CHAR            reduce using rule 26 (statement_part -> expression .)
    STRING          reduce using rule 26 (statement_part -> expression .)
    END             reduce using rule 26 (statement_part -> expression .)
    SEMICOLON       reduce using rule 26 (statement_part -> expression .)
    ELSE            reduce using rule 26 (statement_part -> expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    EQ              shift and go to state 82
    NEQ             shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    GTE             shift and go to state 86
    LTE             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

    sign                           shift and go to state 78
    and_or                         shift and go to state 79

state 47

    (32) assignment_list -> assignment . statement_list
    (20) statement_list -> . statement_part statement_list
    (21) statement_list -> . empty
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (1) empty -> .
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    END             reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    assignment                     shift and go to state 47
    statement_list                 shift and go to state 90
    statement_part                 shift and go to state 40
    empty                          shift and go to state 41
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    expression                     shift and go to state 46
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 48

    (28) while_statement -> WHILE . expression DO statement_part SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    expression                     shift and go to state 91
    term                           shift and go to state 50
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56
    identifier                     shift and go to state 92

state 49

    (29) if_else_statement -> IF . expression THEN statement_list SEMICOLON
    (30) if_else_statement -> IF . expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    expression                     shift and go to state 93
    term                           shift and go to state 50
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56
    identifier                     shift and go to state 92

state 50

    (37) expression -> term .

    PLUS            reduce using rule 37 (expression -> term .)
    MINUS           reduce using rule 37 (expression -> term .)
    EQ              reduce using rule 37 (expression -> term .)
    NEQ             reduce using rule 37 (expression -> term .)
    GT              reduce using rule 37 (expression -> term .)
    LT              reduce using rule 37 (expression -> term .)
    GTE             reduce using rule 37 (expression -> term .)
    LTE             reduce using rule 37 (expression -> term .)
    AND             reduce using rule 37 (expression -> term .)
    OR              reduce using rule 37 (expression -> term .)
    BEGIN           reduce using rule 37 (expression -> term .)
    WHILE           reduce using rule 37 (expression -> term .)
    IF              reduce using rule 37 (expression -> term .)
    IDENTIFIER      reduce using rule 37 (expression -> term .)
    INTEGER         reduce using rule 37 (expression -> term .)
    REAL            reduce using rule 37 (expression -> term .)
    CHAR            reduce using rule 37 (expression -> term .)
    STRING          reduce using rule 37 (expression -> term .)
    END             reduce using rule 37 (expression -> term .)
    SEMICOLON       reduce using rule 37 (expression -> term .)
    ELSE            reduce using rule 37 (expression -> term .)
    DO              reduce using rule 37 (expression -> term .)
    THEN            reduce using rule 37 (expression -> term .)


state 51

    (33) assignment -> identifier . ASSIGNMENT expression ending
    (34) assignment -> identifier . LPARENARR term RPARENARR ASSIGNMENT expression ending
    (55) term -> identifier .
    (60) function_call -> identifier . LPAREN identifier_list RPAREN

    ASSIGNMENT      shift and go to state 94
    LPARENARR       shift and go to state 95
    PLUS            reduce using rule 55 (term -> identifier .)
    MINUS           reduce using rule 55 (term -> identifier .)
    EQ              reduce using rule 55 (term -> identifier .)
    NEQ             reduce using rule 55 (term -> identifier .)
    GT              reduce using rule 55 (term -> identifier .)
    LT              reduce using rule 55 (term -> identifier .)
    GTE             reduce using rule 55 (term -> identifier .)
    LTE             reduce using rule 55 (term -> identifier .)
    AND             reduce using rule 55 (term -> identifier .)
    OR              reduce using rule 55 (term -> identifier .)
    BEGIN           reduce using rule 55 (term -> identifier .)
    WHILE           reduce using rule 55 (term -> identifier .)
    IF              reduce using rule 55 (term -> identifier .)
    IDENTIFIER      reduce using rule 55 (term -> identifier .)
    INTEGER         reduce using rule 55 (term -> identifier .)
    REAL            reduce using rule 55 (term -> identifier .)
    CHAR            reduce using rule 55 (term -> identifier .)
    STRING          reduce using rule 55 (term -> identifier .)
    END             reduce using rule 55 (term -> identifier .)
    SEMICOLON       reduce using rule 55 (term -> identifier .)
    ELSE            reduce using rule 55 (term -> identifier .)
    LPAREN          shift and go to state 96


state 52

    (50) term -> integer .

    PLUS            reduce using rule 50 (term -> integer .)
    MINUS           reduce using rule 50 (term -> integer .)
    EQ              reduce using rule 50 (term -> integer .)
    NEQ             reduce using rule 50 (term -> integer .)
    GT              reduce using rule 50 (term -> integer .)
    LT              reduce using rule 50 (term -> integer .)
    GTE             reduce using rule 50 (term -> integer .)
    LTE             reduce using rule 50 (term -> integer .)
    AND             reduce using rule 50 (term -> integer .)
    OR              reduce using rule 50 (term -> integer .)
    BEGIN           reduce using rule 50 (term -> integer .)
    WHILE           reduce using rule 50 (term -> integer .)
    IF              reduce using rule 50 (term -> integer .)
    IDENTIFIER      reduce using rule 50 (term -> integer .)
    INTEGER         reduce using rule 50 (term -> integer .)
    REAL            reduce using rule 50 (term -> integer .)
    CHAR            reduce using rule 50 (term -> integer .)
    STRING          reduce using rule 50 (term -> integer .)
    END             reduce using rule 50 (term -> integer .)
    SEMICOLON       reduce using rule 50 (term -> integer .)
    ELSE            reduce using rule 50 (term -> integer .)
    DO              reduce using rule 50 (term -> integer .)
    THEN            reduce using rule 50 (term -> integer .)
    RPARENARR       reduce using rule 50 (term -> integer .)


state 53

    (51) term -> real .

    PLUS            reduce using rule 51 (term -> real .)
    MINUS           reduce using rule 51 (term -> real .)
    EQ              reduce using rule 51 (term -> real .)
    NEQ             reduce using rule 51 (term -> real .)
    GT              reduce using rule 51 (term -> real .)
    LT              reduce using rule 51 (term -> real .)
    GTE             reduce using rule 51 (term -> real .)
    LTE             reduce using rule 51 (term -> real .)
    AND             reduce using rule 51 (term -> real .)
    OR              reduce using rule 51 (term -> real .)
    BEGIN           reduce using rule 51 (term -> real .)
    WHILE           reduce using rule 51 (term -> real .)
    IF              reduce using rule 51 (term -> real .)
    IDENTIFIER      reduce using rule 51 (term -> real .)
    INTEGER         reduce using rule 51 (term -> real .)
    REAL            reduce using rule 51 (term -> real .)
    CHAR            reduce using rule 51 (term -> real .)
    STRING          reduce using rule 51 (term -> real .)
    END             reduce using rule 51 (term -> real .)
    SEMICOLON       reduce using rule 51 (term -> real .)
    ELSE            reduce using rule 51 (term -> real .)
    DO              reduce using rule 51 (term -> real .)
    THEN            reduce using rule 51 (term -> real .)
    RPARENARR       reduce using rule 51 (term -> real .)


state 54

    (52) term -> char .

    PLUS            reduce using rule 52 (term -> char .)
    MINUS           reduce using rule 52 (term -> char .)
    EQ              reduce using rule 52 (term -> char .)
    NEQ             reduce using rule 52 (term -> char .)
    GT              reduce using rule 52 (term -> char .)
    LT              reduce using rule 52 (term -> char .)
    GTE             reduce using rule 52 (term -> char .)
    LTE             reduce using rule 52 (term -> char .)
    AND             reduce using rule 52 (term -> char .)
    OR              reduce using rule 52 (term -> char .)
    BEGIN           reduce using rule 52 (term -> char .)
    WHILE           reduce using rule 52 (term -> char .)
    IF              reduce using rule 52 (term -> char .)
    IDENTIFIER      reduce using rule 52 (term -> char .)
    INTEGER         reduce using rule 52 (term -> char .)
    REAL            reduce using rule 52 (term -> char .)
    CHAR            reduce using rule 52 (term -> char .)
    STRING          reduce using rule 52 (term -> char .)
    END             reduce using rule 52 (term -> char .)
    SEMICOLON       reduce using rule 52 (term -> char .)
    ELSE            reduce using rule 52 (term -> char .)
    DO              reduce using rule 52 (term -> char .)
    THEN            reduce using rule 52 (term -> char .)
    RPARENARR       reduce using rule 52 (term -> char .)


state 55

    (53) term -> string .

    PLUS            reduce using rule 53 (term -> string .)
    MINUS           reduce using rule 53 (term -> string .)
    EQ              reduce using rule 53 (term -> string .)
    NEQ             reduce using rule 53 (term -> string .)
    GT              reduce using rule 53 (term -> string .)
    LT              reduce using rule 53 (term -> string .)
    GTE             reduce using rule 53 (term -> string .)
    LTE             reduce using rule 53 (term -> string .)
    AND             reduce using rule 53 (term -> string .)
    OR              reduce using rule 53 (term -> string .)
    BEGIN           reduce using rule 53 (term -> string .)
    WHILE           reduce using rule 53 (term -> string .)
    IF              reduce using rule 53 (term -> string .)
    IDENTIFIER      reduce using rule 53 (term -> string .)
    INTEGER         reduce using rule 53 (term -> string .)
    REAL            reduce using rule 53 (term -> string .)
    CHAR            reduce using rule 53 (term -> string .)
    STRING          reduce using rule 53 (term -> string .)
    END             reduce using rule 53 (term -> string .)
    SEMICOLON       reduce using rule 53 (term -> string .)
    ELSE            reduce using rule 53 (term -> string .)
    DO              reduce using rule 53 (term -> string .)
    THEN            reduce using rule 53 (term -> string .)
    RPARENARR       reduce using rule 53 (term -> string .)


state 56

    (54) term -> function_call .

    PLUS            reduce using rule 54 (term -> function_call .)
    MINUS           reduce using rule 54 (term -> function_call .)
    EQ              reduce using rule 54 (term -> function_call .)
    NEQ             reduce using rule 54 (term -> function_call .)
    GT              reduce using rule 54 (term -> function_call .)
    LT              reduce using rule 54 (term -> function_call .)
    GTE             reduce using rule 54 (term -> function_call .)
    LTE             reduce using rule 54 (term -> function_call .)
    AND             reduce using rule 54 (term -> function_call .)
    OR              reduce using rule 54 (term -> function_call .)
    BEGIN           reduce using rule 54 (term -> function_call .)
    WHILE           reduce using rule 54 (term -> function_call .)
    IF              reduce using rule 54 (term -> function_call .)
    IDENTIFIER      reduce using rule 54 (term -> function_call .)
    INTEGER         reduce using rule 54 (term -> function_call .)
    REAL            reduce using rule 54 (term -> function_call .)
    CHAR            reduce using rule 54 (term -> function_call .)
    STRING          reduce using rule 54 (term -> function_call .)
    END             reduce using rule 54 (term -> function_call .)
    SEMICOLON       reduce using rule 54 (term -> function_call .)
    ELSE            reduce using rule 54 (term -> function_call .)
    DO              reduce using rule 54 (term -> function_call .)
    THEN            reduce using rule 54 (term -> function_call .)
    RPARENARR       reduce using rule 54 (term -> function_call .)


state 57

    (56) integer -> INTEGER .

    PLUS            reduce using rule 56 (integer -> INTEGER .)
    MINUS           reduce using rule 56 (integer -> INTEGER .)
    EQ              reduce using rule 56 (integer -> INTEGER .)
    NEQ             reduce using rule 56 (integer -> INTEGER .)
    GT              reduce using rule 56 (integer -> INTEGER .)
    LT              reduce using rule 56 (integer -> INTEGER .)
    GTE             reduce using rule 56 (integer -> INTEGER .)
    LTE             reduce using rule 56 (integer -> INTEGER .)
    AND             reduce using rule 56 (integer -> INTEGER .)
    OR              reduce using rule 56 (integer -> INTEGER .)
    BEGIN           reduce using rule 56 (integer -> INTEGER .)
    WHILE           reduce using rule 56 (integer -> INTEGER .)
    IF              reduce using rule 56 (integer -> INTEGER .)
    IDENTIFIER      reduce using rule 56 (integer -> INTEGER .)
    INTEGER         reduce using rule 56 (integer -> INTEGER .)
    REAL            reduce using rule 56 (integer -> INTEGER .)
    CHAR            reduce using rule 56 (integer -> INTEGER .)
    STRING          reduce using rule 56 (integer -> INTEGER .)
    END             reduce using rule 56 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 56 (integer -> INTEGER .)
    ELSE            reduce using rule 56 (integer -> INTEGER .)
    DO              reduce using rule 56 (integer -> INTEGER .)
    THEN            reduce using rule 56 (integer -> INTEGER .)
    RPARENARR       reduce using rule 56 (integer -> INTEGER .)


state 58

    (57) real -> REAL .

    PLUS            reduce using rule 57 (real -> REAL .)
    MINUS           reduce using rule 57 (real -> REAL .)
    EQ              reduce using rule 57 (real -> REAL .)
    NEQ             reduce using rule 57 (real -> REAL .)
    GT              reduce using rule 57 (real -> REAL .)
    LT              reduce using rule 57 (real -> REAL .)
    GTE             reduce using rule 57 (real -> REAL .)
    LTE             reduce using rule 57 (real -> REAL .)
    AND             reduce using rule 57 (real -> REAL .)
    OR              reduce using rule 57 (real -> REAL .)
    BEGIN           reduce using rule 57 (real -> REAL .)
    WHILE           reduce using rule 57 (real -> REAL .)
    IF              reduce using rule 57 (real -> REAL .)
    IDENTIFIER      reduce using rule 57 (real -> REAL .)
    INTEGER         reduce using rule 57 (real -> REAL .)
    REAL            reduce using rule 57 (real -> REAL .)
    CHAR            reduce using rule 57 (real -> REAL .)
    STRING          reduce using rule 57 (real -> REAL .)
    END             reduce using rule 57 (real -> REAL .)
    SEMICOLON       reduce using rule 57 (real -> REAL .)
    ELSE            reduce using rule 57 (real -> REAL .)
    DO              reduce using rule 57 (real -> REAL .)
    THEN            reduce using rule 57 (real -> REAL .)
    RPARENARR       reduce using rule 57 (real -> REAL .)


state 59

    (59) char -> CHAR .

    PLUS            reduce using rule 59 (char -> CHAR .)
    MINUS           reduce using rule 59 (char -> CHAR .)
    EQ              reduce using rule 59 (char -> CHAR .)
    NEQ             reduce using rule 59 (char -> CHAR .)
    GT              reduce using rule 59 (char -> CHAR .)
    LT              reduce using rule 59 (char -> CHAR .)
    GTE             reduce using rule 59 (char -> CHAR .)
    LTE             reduce using rule 59 (char -> CHAR .)
    AND             reduce using rule 59 (char -> CHAR .)
    OR              reduce using rule 59 (char -> CHAR .)
    BEGIN           reduce using rule 59 (char -> CHAR .)
    WHILE           reduce using rule 59 (char -> CHAR .)
    IF              reduce using rule 59 (char -> CHAR .)
    IDENTIFIER      reduce using rule 59 (char -> CHAR .)
    INTEGER         reduce using rule 59 (char -> CHAR .)
    REAL            reduce using rule 59 (char -> CHAR .)
    CHAR            reduce using rule 59 (char -> CHAR .)
    STRING          reduce using rule 59 (char -> CHAR .)
    END             reduce using rule 59 (char -> CHAR .)
    SEMICOLON       reduce using rule 59 (char -> CHAR .)
    ELSE            reduce using rule 59 (char -> CHAR .)
    DO              reduce using rule 59 (char -> CHAR .)
    THEN            reduce using rule 59 (char -> CHAR .)
    RPARENARR       reduce using rule 59 (char -> CHAR .)


state 60

    (58) string -> STRING .

    PLUS            reduce using rule 58 (string -> STRING .)
    MINUS           reduce using rule 58 (string -> STRING .)
    EQ              reduce using rule 58 (string -> STRING .)
    NEQ             reduce using rule 58 (string -> STRING .)
    GT              reduce using rule 58 (string -> STRING .)
    LT              reduce using rule 58 (string -> STRING .)
    GTE             reduce using rule 58 (string -> STRING .)
    LTE             reduce using rule 58 (string -> STRING .)
    AND             reduce using rule 58 (string -> STRING .)
    OR              reduce using rule 58 (string -> STRING .)
    BEGIN           reduce using rule 58 (string -> STRING .)
    WHILE           reduce using rule 58 (string -> STRING .)
    IF              reduce using rule 58 (string -> STRING .)
    IDENTIFIER      reduce using rule 58 (string -> STRING .)
    INTEGER         reduce using rule 58 (string -> STRING .)
    REAL            reduce using rule 58 (string -> STRING .)
    CHAR            reduce using rule 58 (string -> STRING .)
    STRING          reduce using rule 58 (string -> STRING .)
    END             reduce using rule 58 (string -> STRING .)
    SEMICOLON       reduce using rule 58 (string -> STRING .)
    ELSE            reduce using rule 58 (string -> STRING .)
    DO              reduce using rule 58 (string -> STRING .)
    THEN            reduce using rule 58 (string -> STRING .)
    RPARENARR       reduce using rule 58 (string -> STRING .)


state 61

    (13) function_declaration -> function_heading SEMICOLON block .

    FUNCTION        reduce using rule 13 (function_declaration -> function_heading SEMICOLON block .)
    BEGIN           reduce using rule 13 (function_declaration -> function_heading SEMICOLON block .)


state 62

    (4) block -> variable_declaration_part . BEGIN statement_list END SEMICOLON

    BEGIN           shift and go to state 97


state 63

    (14) function_heading -> FUNCTION identifier LPAREN . parameters RPAREN COLON simple_type_name
    (15) parameters -> . names_list COLON simple_type_name
    (16) parameters -> . names_list COLON simple_type_name SEMICOLON parameters
    (17) names_list -> . identifier
    (18) names_list -> . identifier COMMA names_list
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 98
    parameters                     shift and go to state 99
    names_list                     shift and go to state 100

state 64

    (63) variable_declaration -> identifier_list COLON simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 101


state 65

    (70) simple_type_name -> SSTRING .

    SEMICOLON       reduce using rule 70 (simple_type_name -> SSTRING .)
    RPAREN          reduce using rule 70 (simple_type_name -> SSTRING .)


state 66

    (71) simple_type_name -> SCHAR .

    SEMICOLON       reduce using rule 71 (simple_type_name -> SCHAR .)
    RPAREN          reduce using rule 71 (simple_type_name -> SCHAR .)


state 67

    (72) simple_type_name -> SREAL .

    SEMICOLON       reduce using rule 72 (simple_type_name -> SREAL .)
    RPAREN          reduce using rule 72 (simple_type_name -> SREAL .)


state 68

    (73) simple_type_name -> SINTEGER .

    SEMICOLON       reduce using rule 73 (simple_type_name -> SINTEGER .)
    RPAREN          reduce using rule 73 (simple_type_name -> SINTEGER .)


state 69

    (74) simple_type_name -> identifier .

    SEMICOLON       reduce using rule 74 (simple_type_name -> identifier .)
    RPAREN          reduce using rule 74 (simple_type_name -> identifier .)


state 70

    (65) variable_declaration -> identifier COLON identifier . SEMICOLON
    (74) simple_type_name -> identifier .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 102

  ! SEMICOLON       [ reduce using rule 74 (simple_type_name -> identifier .) ]


state 71

    (64) variable_declaration -> identifier COLON simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 103


state 72

    (66) variable_declaration -> identifier COLON ARRAY . LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    LPARENARR       shift and go to state 104


state 73

    (68) identifier_list -> identifier COMMA identifier .
    (67) identifier_list -> identifier . COMMA identifier_list
    (68) identifier_list -> identifier . COMMA identifier

    COLON           reduce using rule 68 (identifier_list -> identifier COMMA identifier .)
    RPAREN          reduce using rule 68 (identifier_list -> identifier COMMA identifier .)
    COMMA           shift and go to state 36


state 74

    (67) identifier_list -> identifier COMMA identifier_list .

    COLON           reduce using rule 67 (identifier_list -> identifier COMMA identifier_list .)
    RPAREN          reduce using rule 67 (identifier_list -> identifier COMMA identifier_list .)


state 75

    (19) type_definition -> identifier EQ ARRAY LPARENARR . INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 105


state 76

    (31) compound_statement -> BEGIN statement_list END . ending
    (35) ending -> . SEMICOLON
    (36) ending -> . empty
    (1) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 107
    DOT             reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! SEMICOLON       [ reduce using rule 1 (empty -> .) ]

    ending                         shift and go to state 106
    empty                          shift and go to state 108

state 77

    (20) statement_list -> statement_part statement_list .

    END             reduce using rule 20 (statement_list -> statement_part statement_list .)
    BEGIN           reduce using rule 20 (statement_list -> statement_part statement_list .)
    WHILE           reduce using rule 20 (statement_list -> statement_part statement_list .)
    IF              reduce using rule 20 (statement_list -> statement_part statement_list .)
    IDENTIFIER      reduce using rule 20 (statement_list -> statement_part statement_list .)
    INTEGER         reduce using rule 20 (statement_list -> statement_part statement_list .)
    REAL            reduce using rule 20 (statement_list -> statement_part statement_list .)
    CHAR            reduce using rule 20 (statement_list -> statement_part statement_list .)
    STRING          reduce using rule 20 (statement_list -> statement_part statement_list .)
    SEMICOLON       reduce using rule 20 (statement_list -> statement_part statement_list .)
    ELSE            reduce using rule 20 (statement_list -> statement_part statement_list .)


state 78

    (38) expression -> expression sign . term
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    term                           shift and go to state 109
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56
    identifier                     shift and go to state 92

state 79

    (39) expression -> expression and_or . expression
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    expression                     shift and go to state 110
    term                           shift and go to state 50
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56
    identifier                     shift and go to state 92

state 80

    (42) sign -> PLUS .

    INTEGER         reduce using rule 42 (sign -> PLUS .)
    REAL            reduce using rule 42 (sign -> PLUS .)
    CHAR            reduce using rule 42 (sign -> PLUS .)
    STRING          reduce using rule 42 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 42 (sign -> PLUS .)


state 81

    (43) sign -> MINUS .

    INTEGER         reduce using rule 43 (sign -> MINUS .)
    REAL            reduce using rule 43 (sign -> MINUS .)
    CHAR            reduce using rule 43 (sign -> MINUS .)
    STRING          reduce using rule 43 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 43 (sign -> MINUS .)


state 82

    (44) sign -> EQ .

    INTEGER         reduce using rule 44 (sign -> EQ .)
    REAL            reduce using rule 44 (sign -> EQ .)
    CHAR            reduce using rule 44 (sign -> EQ .)
    STRING          reduce using rule 44 (sign -> EQ .)
    IDENTIFIER      reduce using rule 44 (sign -> EQ .)


state 83

    (45) sign -> NEQ .

    INTEGER         reduce using rule 45 (sign -> NEQ .)
    REAL            reduce using rule 45 (sign -> NEQ .)
    CHAR            reduce using rule 45 (sign -> NEQ .)
    STRING          reduce using rule 45 (sign -> NEQ .)
    IDENTIFIER      reduce using rule 45 (sign -> NEQ .)


state 84

    (46) sign -> GT .

    INTEGER         reduce using rule 46 (sign -> GT .)
    REAL            reduce using rule 46 (sign -> GT .)
    CHAR            reduce using rule 46 (sign -> GT .)
    STRING          reduce using rule 46 (sign -> GT .)
    IDENTIFIER      reduce using rule 46 (sign -> GT .)


state 85

    (47) sign -> LT .

    INTEGER         reduce using rule 47 (sign -> LT .)
    REAL            reduce using rule 47 (sign -> LT .)
    CHAR            reduce using rule 47 (sign -> LT .)
    STRING          reduce using rule 47 (sign -> LT .)
    IDENTIFIER      reduce using rule 47 (sign -> LT .)


state 86

    (48) sign -> GTE .

    INTEGER         reduce using rule 48 (sign -> GTE .)
    REAL            reduce using rule 48 (sign -> GTE .)
    CHAR            reduce using rule 48 (sign -> GTE .)
    STRING          reduce using rule 48 (sign -> GTE .)
    IDENTIFIER      reduce using rule 48 (sign -> GTE .)


state 87

    (49) sign -> LTE .

    INTEGER         reduce using rule 49 (sign -> LTE .)
    REAL            reduce using rule 49 (sign -> LTE .)
    CHAR            reduce using rule 49 (sign -> LTE .)
    STRING          reduce using rule 49 (sign -> LTE .)
    IDENTIFIER      reduce using rule 49 (sign -> LTE .)


state 88

    (40) and_or -> AND .

    INTEGER         reduce using rule 40 (and_or -> AND .)
    REAL            reduce using rule 40 (and_or -> AND .)
    CHAR            reduce using rule 40 (and_or -> AND .)
    STRING          reduce using rule 40 (and_or -> AND .)
    IDENTIFIER      reduce using rule 40 (and_or -> AND .)


state 89

    (41) and_or -> OR .

    INTEGER         reduce using rule 41 (and_or -> OR .)
    REAL            reduce using rule 41 (and_or -> OR .)
    CHAR            reduce using rule 41 (and_or -> OR .)
    STRING          reduce using rule 41 (and_or -> OR .)
    IDENTIFIER      reduce using rule 41 (and_or -> OR .)


state 90

    (32) assignment_list -> assignment statement_list .

    BEGIN           reduce using rule 32 (assignment_list -> assignment statement_list .)
    WHILE           reduce using rule 32 (assignment_list -> assignment statement_list .)
    IF              reduce using rule 32 (assignment_list -> assignment statement_list .)
    IDENTIFIER      reduce using rule 32 (assignment_list -> assignment statement_list .)
    INTEGER         reduce using rule 32 (assignment_list -> assignment statement_list .)
    REAL            reduce using rule 32 (assignment_list -> assignment statement_list .)
    CHAR            reduce using rule 32 (assignment_list -> assignment statement_list .)
    STRING          reduce using rule 32 (assignment_list -> assignment statement_list .)
    END             reduce using rule 32 (assignment_list -> assignment statement_list .)
    SEMICOLON       reduce using rule 32 (assignment_list -> assignment statement_list .)
    ELSE            reduce using rule 32 (assignment_list -> assignment statement_list .)


state 91

    (28) while_statement -> WHILE expression . DO statement_part SEMICOLON
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

    DO              shift and go to state 111
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    EQ              shift and go to state 82
    NEQ             shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    GTE             shift and go to state 86
    LTE             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

    sign                           shift and go to state 78
    and_or                         shift and go to state 79

state 92

    (55) term -> identifier .
    (60) function_call -> identifier . LPAREN identifier_list RPAREN

    DO              reduce using rule 55 (term -> identifier .)
    PLUS            reduce using rule 55 (term -> identifier .)
    MINUS           reduce using rule 55 (term -> identifier .)
    EQ              reduce using rule 55 (term -> identifier .)
    NEQ             reduce using rule 55 (term -> identifier .)
    GT              reduce using rule 55 (term -> identifier .)
    LT              reduce using rule 55 (term -> identifier .)
    GTE             reduce using rule 55 (term -> identifier .)
    LTE             reduce using rule 55 (term -> identifier .)
    AND             reduce using rule 55 (term -> identifier .)
    OR              reduce using rule 55 (term -> identifier .)
    THEN            reduce using rule 55 (term -> identifier .)
    BEGIN           reduce using rule 55 (term -> identifier .)
    WHILE           reduce using rule 55 (term -> identifier .)
    IF              reduce using rule 55 (term -> identifier .)
    IDENTIFIER      reduce using rule 55 (term -> identifier .)
    INTEGER         reduce using rule 55 (term -> identifier .)
    REAL            reduce using rule 55 (term -> identifier .)
    CHAR            reduce using rule 55 (term -> identifier .)
    STRING          reduce using rule 55 (term -> identifier .)
    END             reduce using rule 55 (term -> identifier .)
    SEMICOLON       reduce using rule 55 (term -> identifier .)
    ELSE            reduce using rule 55 (term -> identifier .)
    RPARENARR       reduce using rule 55 (term -> identifier .)
    LPAREN          shift and go to state 96


state 93

    (29) if_else_statement -> IF expression . THEN statement_list SEMICOLON
    (30) if_else_statement -> IF expression . THEN statement_list ELSE statement_list SEMICOLON
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

    THEN            shift and go to state 112
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    EQ              shift and go to state 82
    NEQ             shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    GTE             shift and go to state 86
    LTE             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

    sign                           shift and go to state 78
    and_or                         shift and go to state 79

state 94

    (33) assignment -> identifier ASSIGNMENT . expression ending
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 92
    expression                     shift and go to state 113
    term                           shift and go to state 50
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 95

    (34) assignment -> identifier LPARENARR . term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 92
    term                           shift and go to state 114
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 96

    (60) function_call -> identifier LPAREN . identifier_list RPAREN
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    IDENTIFIER      shift and go to state 8
    RPAREN          reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 115
    identifier_list                shift and go to state 116
    empty                          shift and go to state 25

state 97

    (4) block -> variable_declaration_part BEGIN . statement_list END SEMICOLON
    (20) statement_list -> . statement_part statement_list
    (21) statement_list -> . empty
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (1) empty -> .
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    END             reduce using rule 1 (empty -> .)
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    statement_list                 shift and go to state 117
    statement_part                 shift and go to state 40
    empty                          shift and go to state 41
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    expression                     shift and go to state 46
    assignment                     shift and go to state 47
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 98

    (17) names_list -> identifier .
    (18) names_list -> identifier . COMMA names_list

    COLON           reduce using rule 17 (names_list -> identifier .)
    COMMA           shift and go to state 118


state 99

    (14) function_heading -> FUNCTION identifier LPAREN parameters . RPAREN COLON simple_type_name

    RPAREN          shift and go to state 119


state 100

    (15) parameters -> names_list . COLON simple_type_name
    (16) parameters -> names_list . COLON simple_type_name SEMICOLON parameters

    COLON           shift and go to state 120


state 101

    (63) variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    COLON           reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)


state 102

    (65) variable_declaration -> identifier COLON identifier SEMICOLON .

    IDENTIFIER      reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    COLON           reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    FUNCTION        reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    BEGIN           reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)


state 103

    (64) variable_declaration -> identifier COLON simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    COLON           reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)


state 104

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR . INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 121


state 105

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER . DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    DD              shift and go to state 122


state 106

    (31) compound_statement -> BEGIN statement_list END ending .

    DOT             reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    BEGIN           reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    WHILE           reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    IF              reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    IDENTIFIER      reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    INTEGER         reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    REAL            reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    CHAR            reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    STRING          reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    END             reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    SEMICOLON       reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)
    ELSE            reduce using rule 31 (compound_statement -> BEGIN statement_list END ending .)


state 107

    (35) ending -> SEMICOLON .

    DOT             reduce using rule 35 (ending -> SEMICOLON .)
    BEGIN           reduce using rule 35 (ending -> SEMICOLON .)
    WHILE           reduce using rule 35 (ending -> SEMICOLON .)
    IF              reduce using rule 35 (ending -> SEMICOLON .)
    IDENTIFIER      reduce using rule 35 (ending -> SEMICOLON .)
    INTEGER         reduce using rule 35 (ending -> SEMICOLON .)
    REAL            reduce using rule 35 (ending -> SEMICOLON .)
    CHAR            reduce using rule 35 (ending -> SEMICOLON .)
    STRING          reduce using rule 35 (ending -> SEMICOLON .)
    END             reduce using rule 35 (ending -> SEMICOLON .)
    SEMICOLON       reduce using rule 35 (ending -> SEMICOLON .)
    ELSE            reduce using rule 35 (ending -> SEMICOLON .)


state 108

    (36) ending -> empty .

    DOT             reduce using rule 36 (ending -> empty .)
    BEGIN           reduce using rule 36 (ending -> empty .)
    WHILE           reduce using rule 36 (ending -> empty .)
    IF              reduce using rule 36 (ending -> empty .)
    IDENTIFIER      reduce using rule 36 (ending -> empty .)
    INTEGER         reduce using rule 36 (ending -> empty .)
    REAL            reduce using rule 36 (ending -> empty .)
    CHAR            reduce using rule 36 (ending -> empty .)
    STRING          reduce using rule 36 (ending -> empty .)
    END             reduce using rule 36 (ending -> empty .)
    SEMICOLON       reduce using rule 36 (ending -> empty .)
    ELSE            reduce using rule 36 (ending -> empty .)


state 109

    (38) expression -> expression sign term .

    PLUS            reduce using rule 38 (expression -> expression sign term .)
    MINUS           reduce using rule 38 (expression -> expression sign term .)
    EQ              reduce using rule 38 (expression -> expression sign term .)
    NEQ             reduce using rule 38 (expression -> expression sign term .)
    GT              reduce using rule 38 (expression -> expression sign term .)
    LT              reduce using rule 38 (expression -> expression sign term .)
    GTE             reduce using rule 38 (expression -> expression sign term .)
    LTE             reduce using rule 38 (expression -> expression sign term .)
    AND             reduce using rule 38 (expression -> expression sign term .)
    OR              reduce using rule 38 (expression -> expression sign term .)
    BEGIN           reduce using rule 38 (expression -> expression sign term .)
    WHILE           reduce using rule 38 (expression -> expression sign term .)
    IF              reduce using rule 38 (expression -> expression sign term .)
    IDENTIFIER      reduce using rule 38 (expression -> expression sign term .)
    INTEGER         reduce using rule 38 (expression -> expression sign term .)
    REAL            reduce using rule 38 (expression -> expression sign term .)
    CHAR            reduce using rule 38 (expression -> expression sign term .)
    STRING          reduce using rule 38 (expression -> expression sign term .)
    END             reduce using rule 38 (expression -> expression sign term .)
    SEMICOLON       reduce using rule 38 (expression -> expression sign term .)
    ELSE            reduce using rule 38 (expression -> expression sign term .)
    DO              reduce using rule 38 (expression -> expression sign term .)
    THEN            reduce using rule 38 (expression -> expression sign term .)


state 110

    (39) expression -> expression and_or expression .
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BEGIN           reduce using rule 39 (expression -> expression and_or expression .)
    WHILE           reduce using rule 39 (expression -> expression and_or expression .)
    IF              reduce using rule 39 (expression -> expression and_or expression .)
    IDENTIFIER      reduce using rule 39 (expression -> expression and_or expression .)
    INTEGER         reduce using rule 39 (expression -> expression and_or expression .)
    REAL            reduce using rule 39 (expression -> expression and_or expression .)
    CHAR            reduce using rule 39 (expression -> expression and_or expression .)
    STRING          reduce using rule 39 (expression -> expression and_or expression .)
    END             reduce using rule 39 (expression -> expression and_or expression .)
    SEMICOLON       reduce using rule 39 (expression -> expression and_or expression .)
    ELSE            reduce using rule 39 (expression -> expression and_or expression .)
    DO              reduce using rule 39 (expression -> expression and_or expression .)
    THEN            reduce using rule 39 (expression -> expression and_or expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    EQ              shift and go to state 82
    NEQ             shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    GTE             shift and go to state 86
    LTE             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! PLUS            [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! EQ              [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! NEQ             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! GT              [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! LT              [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! GTE             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! LTE             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! AND             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! OR              [ reduce using rule 39 (expression -> expression and_or expression .) ]

    and_or                         shift and go to state 79
    sign                           shift and go to state 78

state 111

    (28) while_statement -> WHILE expression DO . statement_part SEMICOLON
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    SEMICOLON       reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

    expression                     shift and go to state 46
    statement_part                 shift and go to state 123
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    empty                          shift and go to state 124
    assignment                     shift and go to state 47
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 112

    (29) if_else_statement -> IF expression THEN . statement_list SEMICOLON
    (30) if_else_statement -> IF expression THEN . statement_list ELSE statement_list SEMICOLON
    (20) statement_list -> . statement_part statement_list
    (21) statement_list -> . empty
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (1) empty -> .
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    SEMICOLON       reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    expression                     shift and go to state 46
    statement_list                 shift and go to state 125
    statement_part                 shift and go to state 40
    empty                          shift and go to state 41
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    assignment                     shift and go to state 47
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 113

    (33) assignment -> identifier ASSIGNMENT expression . ending
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (35) ending -> . SEMICOLON
    (36) ending -> . empty
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR
    (1) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 107
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    EQ              shift and go to state 82
    NEQ             shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    GTE             shift and go to state 86
    LTE             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! SEMICOLON       [ reduce using rule 1 (empty -> .) ]

    ending                         shift and go to state 126
    sign                           shift and go to state 78
    and_or                         shift and go to state 79
    empty                          shift and go to state 108

state 114

    (34) assignment -> identifier LPARENARR term . RPARENARR ASSIGNMENT expression ending

    RPARENARR       shift and go to state 127


state 115

    (67) identifier_list -> identifier . COMMA identifier_list
    (68) identifier_list -> identifier . COMMA identifier

    COMMA           shift and go to state 36


state 116

    (60) function_call -> identifier LPAREN identifier_list . RPAREN

    RPAREN          shift and go to state 128


state 117

    (4) block -> variable_declaration_part BEGIN statement_list . END SEMICOLON

    END             shift and go to state 129


state 118

    (18) names_list -> identifier COMMA . names_list
    (17) names_list -> . identifier
    (18) names_list -> . identifier COMMA names_list
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 98
    names_list                     shift and go to state 130

state 119

    (14) function_heading -> FUNCTION identifier LPAREN parameters RPAREN . COLON simple_type_name

    COLON           shift and go to state 131


state 120

    (15) parameters -> names_list COLON . simple_type_name
    (16) parameters -> names_list COLON . simple_type_name SEMICOLON parameters
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 65
    SCHAR           shift and go to state 66
    SREAL           shift and go to state 67
    SINTEGER        shift and go to state 68
    IDENTIFIER      shift and go to state 8

    simple_type_name               shift and go to state 132
    identifier                     shift and go to state 69

state 121

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER . DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    DD              shift and go to state 133


state 122

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD . INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 134


state 123

    (28) while_statement -> WHILE expression DO statement_part . SEMICOLON

    SEMICOLON       shift and go to state 135


state 124

    (27) statement_part -> empty .

    SEMICOLON       reduce using rule 27 (statement_part -> empty .)


state 125

    (29) if_else_statement -> IF expression THEN statement_list . SEMICOLON
    (30) if_else_statement -> IF expression THEN statement_list . ELSE statement_list SEMICOLON

    SEMICOLON       shift and go to state 136
    ELSE            shift and go to state 137


state 126

    (33) assignment -> identifier ASSIGNMENT expression ending .

    BEGIN           reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    WHILE           reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    IF              reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    IDENTIFIER      reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    INTEGER         reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    REAL            reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    CHAR            reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    STRING          reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    END             reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    SEMICOLON       reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)
    ELSE            reduce using rule 33 (assignment -> identifier ASSIGNMENT expression ending .)


state 127

    (34) assignment -> identifier LPARENARR term RPARENARR . ASSIGNMENT expression ending

    ASSIGNMENT      shift and go to state 138


state 128

    (60) function_call -> identifier LPAREN identifier_list RPAREN .

    PLUS            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    MINUS           reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    EQ              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    NEQ             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    GT              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    LT              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    GTE             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    LTE             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    AND             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    OR              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    BEGIN           reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    WHILE           reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    IF              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    IDENTIFIER      reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    INTEGER         reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    REAL            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    CHAR            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    STRING          reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    END             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    SEMICOLON       reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    ELSE            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    DO              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    THEN            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    RPARENARR       reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)


state 129

    (4) block -> variable_declaration_part BEGIN statement_list END . SEMICOLON

    SEMICOLON       shift and go to state 139


state 130

    (18) names_list -> identifier COMMA names_list .

    COLON           reduce using rule 18 (names_list -> identifier COMMA names_list .)


state 131

    (14) function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON . simple_type_name
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 65
    SCHAR           shift and go to state 66
    SREAL           shift and go to state 67
    SINTEGER        shift and go to state 68
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 69
    simple_type_name               shift and go to state 140

state 132

    (15) parameters -> names_list COLON simple_type_name .
    (16) parameters -> names_list COLON simple_type_name . SEMICOLON parameters

    RPAREN          reduce using rule 15 (parameters -> names_list COLON simple_type_name .)
    SEMICOLON       shift and go to state 141


state 133

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD . INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 142


state 134

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER . RPARENARR OF simple_type_name SEMICOLON

    RPARENARR       shift and go to state 143


state 135

    (28) while_statement -> WHILE expression DO statement_part SEMICOLON .

    BEGIN           reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    WHILE           reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    IF              reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    INTEGER         reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    REAL            reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    CHAR            reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    STRING          reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    END             reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    SEMICOLON       reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)
    ELSE            reduce using rule 28 (while_statement -> WHILE expression DO statement_part SEMICOLON .)


state 136

    (29) if_else_statement -> IF expression THEN statement_list SEMICOLON .

    BEGIN           reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    WHILE           reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    IF              reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    INTEGER         reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    REAL            reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    CHAR            reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    STRING          reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    END             reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    SEMICOLON       reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)
    ELSE            reduce using rule 29 (if_else_statement -> IF expression THEN statement_list SEMICOLON .)


state 137

    (30) if_else_statement -> IF expression THEN statement_list ELSE . statement_list SEMICOLON
    (20) statement_list -> . statement_part statement_list
    (21) statement_list -> . empty
    (22) statement_part -> . compound_statement
    (23) statement_part -> . assignment_list
    (24) statement_part -> . while_statement
    (25) statement_part -> . if_else_statement
    (26) statement_part -> . expression
    (27) statement_part -> . empty
    (1) empty -> .
    (31) compound_statement -> . BEGIN statement_list END ending
    (32) assignment_list -> . assignment statement_list
    (28) while_statement -> . WHILE expression DO statement_part SEMICOLON
    (29) if_else_statement -> . IF expression THEN statement_list SEMICOLON
    (30) if_else_statement -> . IF expression THEN statement_list ELSE statement_list SEMICOLON
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (33) assignment -> . identifier ASSIGNMENT expression ending
    (34) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    SEMICOLON       reduce using rule 1 (empty -> .)
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 48
    IF              shift and go to state 49
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    expression                     shift and go to state 46
    statement_list                 shift and go to state 144
    statement_part                 shift and go to state 40
    empty                          shift and go to state 41
    compound_statement             shift and go to state 42
    assignment_list                shift and go to state 43
    while_statement                shift and go to state 44
    if_else_statement              shift and go to state 45
    assignment                     shift and go to state 47
    term                           shift and go to state 50
    identifier                     shift and go to state 51
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 138

    (34) assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT . expression ending
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 57
    REAL            shift and go to state 58
    CHAR            shift and go to state 59
    STRING          shift and go to state 60
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 92
    term                           shift and go to state 50
    expression                     shift and go to state 145
    integer                        shift and go to state 52
    real                           shift and go to state 53
    char                           shift and go to state 54
    string                         shift and go to state 55
    function_call                  shift and go to state 56

state 139

    (4) block -> variable_declaration_part BEGIN statement_list END SEMICOLON .

    FUNCTION        reduce using rule 4 (block -> variable_declaration_part BEGIN statement_list END SEMICOLON .)
    BEGIN           reduce using rule 4 (block -> variable_declaration_part BEGIN statement_list END SEMICOLON .)


state 140

    (14) function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name .

    SEMICOLON       reduce using rule 14 (function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name .)


state 141

    (16) parameters -> names_list COLON simple_type_name SEMICOLON . parameters
    (15) parameters -> . names_list COLON simple_type_name
    (16) parameters -> . names_list COLON simple_type_name SEMICOLON parameters
    (17) names_list -> . identifier
    (18) names_list -> . identifier COMMA names_list
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    names_list                     shift and go to state 100
    parameters                     shift and go to state 146
    identifier                     shift and go to state 98

state 142

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER . RPARENARR OF simple_type_name SEMICOLON

    RPARENARR       shift and go to state 147


state 143

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR . OF simple_type_name SEMICOLON

    OF              shift and go to state 148


state 144

    (30) if_else_statement -> IF expression THEN statement_list ELSE statement_list . SEMICOLON

    SEMICOLON       shift and go to state 149


state 145

    (34) assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression . ending
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (35) ending -> . SEMICOLON
    (36) ending -> . empty
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR
    (1) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 107
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    EQ              shift and go to state 82
    NEQ             shift and go to state 83
    GT              shift and go to state 84
    LT              shift and go to state 85
    GTE             shift and go to state 86
    LTE             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! SEMICOLON       [ reduce using rule 1 (empty -> .) ]

    ending                         shift and go to state 150
    sign                           shift and go to state 78
    and_or                         shift and go to state 79
    empty                          shift and go to state 108

state 146

    (16) parameters -> names_list COLON simple_type_name SEMICOLON parameters .

    RPAREN          reduce using rule 16 (parameters -> names_list COLON simple_type_name SEMICOLON parameters .)


state 147

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR . OF simple_type_name SEMICOLON

    OF              shift and go to state 151


state 148

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF . simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 65
    SCHAR           shift and go to state 66
    SREAL           shift and go to state 67
    SINTEGER        shift and go to state 68
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 69
    simple_type_name               shift and go to state 152

state 149

    (30) if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .

    BEGIN           reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    WHILE           reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    IF              reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    INTEGER         reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    REAL            reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    CHAR            reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    STRING          reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    END             reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    SEMICOLON       reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)
    ELSE            reduce using rule 30 (if_else_statement -> IF expression THEN statement_list ELSE statement_list SEMICOLON .)


state 150

    (34) assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .

    BEGIN           reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    WHILE           reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    IF              reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    IDENTIFIER      reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    INTEGER         reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    REAL            reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    CHAR            reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    STRING          reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    END             reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    SEMICOLON       reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    ELSE            reduce using rule 34 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)


state 151

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF . simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 65
    SCHAR           shift and go to state 66
    SREAL           shift and go to state 67
    SINTEGER        shift and go to state 68
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 69
    simple_type_name               shift and go to state 153

state 152

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 154


state 153

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 155


state 154

    (19) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 19 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    VAR             reduce using rule 19 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 19 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 19 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)


state 155

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    COLON           reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for BEGIN in state 29 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 29 resolved as shift
WARNING: shift/reduce conflict for IF in state 29 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 29 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 29 resolved as shift
WARNING: shift/reduce conflict for REAL in state 29 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 29 resolved as shift
WARNING: shift/reduce conflict for STRING in state 29 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 40 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 40 resolved as shift
WARNING: shift/reduce conflict for REAL in state 40 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 40 resolved as shift
WARNING: shift/reduce conflict for STRING in state 40 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 47 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 47 resolved as shift
WARNING: shift/reduce conflict for REAL in state 47 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 47 resolved as shift
WARNING: shift/reduce conflict for STRING in state 47 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 70 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 76 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 97 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 97 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 97 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 97 resolved as shift
WARNING: shift/reduce conflict for REAL in state 97 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 97 resolved as shift
WARNING: shift/reduce conflict for STRING in state 97 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for EQ in state 110 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 110 resolved as shift
WARNING: shift/reduce conflict for GT in state 110 resolved as shift
WARNING: shift/reduce conflict for LT in state 110 resolved as shift
WARNING: shift/reduce conflict for GTE in state 110 resolved as shift
WARNING: shift/reduce conflict for LTE in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for OR in state 110 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 112 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 112 resolved as shift
WARNING: shift/reduce conflict for IF in state 112 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 112 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 112 resolved as shift
WARNING: shift/reduce conflict for REAL in state 112 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 112 resolved as shift
WARNING: shift/reduce conflict for STRING in state 112 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 113 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 137 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 137 resolved as shift
WARNING: shift/reduce conflict for IF in state 137 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 137 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 137 resolved as shift
WARNING: shift/reduce conflict for REAL in state 137 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 137 resolved as shift
WARNING: shift/reduce conflict for STRING in state 137 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 145 resolved as shift
WARNING: reduce/reduce conflict in state 41 resolved using rule (statement_list -> empty)
WARNING: rejected rule (statement_part -> empty) in state 41
