Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement
Rule 3     program_heading -> PROGRAM identifier SEMICOLON
Rule 4     declaration_part -> type_definition_part variable_declaration_part function_declaration_part
Rule 5     block -> declaration_part statement_part
Rule 6     type_definition_part -> TYPE type_definition_list
Rule 7     type_definition_part -> empty
Rule 8     type_definition_list -> type_definition
Rule 9     type_definition_list -> type_definition type_definition_list
Rule 10    variable_declaration_part -> VAR variable_declaration_list
Rule 11    variable_declaration_part -> empty
Rule 12    function_declaration_part -> function_declaration function_declaration_part
Rule 13    function_declaration_part -> empty
Rule 14    function_declaration -> function_heading SEMICOLON block
Rule 15    function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name
Rule 16    parameters -> names_list COLON simple_type_name
Rule 17    parameters -> names_list COLON simple_type_name SEMICOLON parameters
Rule 18    names_list -> identifier
Rule 19    names_list -> identifier COMMA names_list
Rule 20    type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
Rule 21    statement_part -> compound_statement
Rule 22    statement_part -> assignment_list
Rule 23    statement_part -> while_statement
Rule 24    statement_part -> if_else_statement
Rule 25    statement_part -> expression
Rule 26    statement_part -> empty
Rule 27    while_statement -> WHILE expression DO statement_part
Rule 28    ending -> SEMICOLON
Rule 29    ending -> empty
Rule 30    if_else_statement -> IF expression THEN statement_part
Rule 31    if_else_statement -> IF expression THEN statement_part ELSE statement_part
Rule 32    compound_statement -> BEGIN statement_part END SEMICOLON
Rule 33    compound_statement -> BEGIN statement_part END DOT
Rule 34    assignment_list -> assignment statement_part
Rule 35    assignment -> identifier ASSIGNMENT expression ending
Rule 36    assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
Rule 37    expression -> term
Rule 38    expression -> expression sign term
Rule 39    expression -> expression and_or expression
Rule 40    and_or -> AND
Rule 41    and_or -> OR
Rule 42    sign -> PLUS
Rule 43    sign -> MINUS
Rule 44    sign -> EQ
Rule 45    sign -> NEQ
Rule 46    sign -> GT
Rule 47    sign -> LT
Rule 48    sign -> GTE
Rule 49    sign -> LTE
Rule 50    term -> integer
Rule 51    term -> real
Rule 52    term -> char
Rule 53    term -> string
Rule 54    term -> function_call
Rule 55    term -> identifier
Rule 56    integer -> INTEGER
Rule 57    real -> REAL
Rule 58    string -> STRING
Rule 59    char -> CHAR
Rule 60    function_call -> identifier LPAREN identifier_list RPAREN
Rule 61    variable_declaration_list -> variable_declaration
Rule 62    variable_declaration_list -> variable_declaration variable_declaration_list
Rule 63    variable_declaration -> identifier_list COLON simple_type_name SEMICOLON
Rule 64    variable_declaration -> identifier COLON simple_type_name SEMICOLON
Rule 65    variable_declaration -> identifier COLON identifier SEMICOLON
Rule 66    variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
Rule 67    identifier_list -> identifier COMMA identifier_list
Rule 68    identifier_list -> identifier COMMA identifier
Rule 69    identifier_list -> empty
Rule 70    simple_type_name -> SSTRING
Rule 71    simple_type_name -> SCHAR
Rule 72    simple_type_name -> SREAL
Rule 73    simple_type_name -> SINTEGER
Rule 74    simple_type_name -> identifier
Rule 75    identifier -> IDENTIFIER

Terminals, with rules where they appear

AND                  : 40
ARRAY                : 20 66
ASSIGNMENT           : 35 36
BEGIN                : 32 33
CHAR                 : 59
COLON                : 15 16 17 63 64 65 66
COMMA                : 19 67 68
DD                   : 20 66
DO                   : 27
DOT                  : 33
ELSE                 : 31
END                  : 32 33
EQ                   : 20 44
FUNCTION             : 15
GT                   : 46
GTE                  : 48
IDENTIFIER           : 75
IF                   : 30 31
INTEGER              : 20 20 56 66 66
LPAREN               : 15 60
LPARENARR            : 20 36 66
LT                   : 47
LTE                  : 49
MINUS                : 43
NEQ                  : 45
OF                   : 20 66
OR                   : 41
PLUS                 : 42
PROGRAM              : 3
REAL                 : 57
RPAREN               : 15 60
RPARENARR            : 20 36 66
SCHAR                : 71
SEMICOLON            : 3 14 17 20 28 32 63 64 65 66
SINTEGER             : 73
SREAL                : 72
SSTRING              : 70
STRING               : 58
THEN                 : 30 31
TYPE                 : 6
VAR                  : 10
WHILE                : 27
error                : 

Nonterminals, with rules where they appear

and_or               : 39
assignment           : 34
assignment_list      : 22
block                : 14
char                 : 52
compound_statement   : 2 21
declaration_part     : 5
empty                : 7 11 13 26 29 69
ending               : 35 36
expression           : 25 27 30 31 35 36 38 39 39
function_call        : 54
function_declaration : 12
function_declaration_part : 2 4 12
function_heading     : 14
identifier           : 3 15 18 19 20 35 36 55 60 64 65 65 66 67 68 68 74
identifier_list      : 60 63 67
if_else_statement    : 24
integer              : 50
names_list           : 16 17 19
parameters           : 15 17
program              : 0
program_heading      : 2
real                 : 51
sign                 : 38
simple_type_name     : 15 16 17 20 63 64 66
statement_part       : 5 27 30 31 31 32 33 34
string               : 53
term                 : 36 37 38
type_definition      : 8 9
type_definition_list : 6 9
type_definition_part : 2 4
variable_declaration : 61 62
variable_declaration_list : 10 62
variable_declaration_part : 2 4
while_statement      : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement
    (3) program_heading -> . PROGRAM identifier SEMICOLON

    PROGRAM         shift and go to state 3

    program                        shift and go to state 1
    program_heading                shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (2) program -> program_heading . type_definition_part variable_declaration_part function_declaration_part compound_statement
    (6) type_definition_part -> . TYPE type_definition_list
    (7) type_definition_part -> . empty
    (1) empty -> .

    TYPE            shift and go to state 5
    VAR             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    type_definition_part           shift and go to state 4
    empty                          shift and go to state 6

state 3

    (3) program_heading -> PROGRAM . identifier SEMICOLON
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 7

state 4

    (2) program -> program_heading type_definition_part . variable_declaration_part function_declaration_part compound_statement
    (10) variable_declaration_part -> . VAR variable_declaration_list
    (11) variable_declaration_part -> . empty
    (1) empty -> .

    VAR             shift and go to state 10
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    variable_declaration_part      shift and go to state 9
    empty                          shift and go to state 11

state 5

    (6) type_definition_part -> TYPE . type_definition_list
    (8) type_definition_list -> . type_definition
    (9) type_definition_list -> . type_definition type_definition_list
    (20) type_definition -> . identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    type_definition_list           shift and go to state 12
    type_definition                shift and go to state 13
    identifier                     shift and go to state 14

state 6

    (7) type_definition_part -> empty .

    VAR             reduce using rule 7 (type_definition_part -> empty .)
    FUNCTION        reduce using rule 7 (type_definition_part -> empty .)
    BEGIN           reduce using rule 7 (type_definition_part -> empty .)
    WHILE           reduce using rule 7 (type_definition_part -> empty .)
    IF              reduce using rule 7 (type_definition_part -> empty .)
    IDENTIFIER      reduce using rule 7 (type_definition_part -> empty .)
    INTEGER         reduce using rule 7 (type_definition_part -> empty .)
    REAL            reduce using rule 7 (type_definition_part -> empty .)
    CHAR            reduce using rule 7 (type_definition_part -> empty .)
    STRING          reduce using rule 7 (type_definition_part -> empty .)


state 7

    (3) program_heading -> PROGRAM identifier . SEMICOLON

    SEMICOLON       shift and go to state 15


state 8

    (75) identifier -> IDENTIFIER .

    SEMICOLON       reduce using rule 75 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 75 (identifier -> IDENTIFIER .)
    COLON           reduce using rule 75 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 75 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 75 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 75 (identifier -> IDENTIFIER .)
    LPARENARR       reduce using rule 75 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 75 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 75 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 75 (identifier -> IDENTIFIER .)
    GT              reduce using rule 75 (identifier -> IDENTIFIER .)
    LT              reduce using rule 75 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 75 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 75 (identifier -> IDENTIFIER .)
    AND             reduce using rule 75 (identifier -> IDENTIFIER .)
    OR              reduce using rule 75 (identifier -> IDENTIFIER .)
    END             reduce using rule 75 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (identifier -> IDENTIFIER .)
    BEGIN           reduce using rule 75 (identifier -> IDENTIFIER .)
    WHILE           reduce using rule 75 (identifier -> IDENTIFIER .)
    IF              reduce using rule 75 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 75 (identifier -> IDENTIFIER .)
    INTEGER         reduce using rule 75 (identifier -> IDENTIFIER .)
    REAL            reduce using rule 75 (identifier -> IDENTIFIER .)
    CHAR            reduce using rule 75 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 75 (identifier -> IDENTIFIER .)
    FUNCTION        reduce using rule 75 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 75 (identifier -> IDENTIFIER .)
    DO              reduce using rule 75 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 75 (identifier -> IDENTIFIER .)
    RPARENARR       reduce using rule 75 (identifier -> IDENTIFIER .)


state 9

    (2) program -> program_heading type_definition_part variable_declaration_part . function_declaration_part compound_statement
    (12) function_declaration_part -> . function_declaration function_declaration_part
    (13) function_declaration_part -> . empty
    (14) function_declaration -> . function_heading SEMICOLON block
    (1) empty -> .
    (15) function_heading -> . FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name

    BEGIN           reduce using rule 1 (empty -> .)
    FUNCTION        shift and go to state 20

    function_declaration_part      shift and go to state 16
    function_declaration           shift and go to state 17
    empty                          shift and go to state 18
    function_heading               shift and go to state 19

state 10

    (10) variable_declaration_part -> VAR . variable_declaration_list
    (61) variable_declaration_list -> . variable_declaration
    (62) variable_declaration_list -> . variable_declaration variable_declaration_list
    (63) variable_declaration -> . identifier_list COLON simple_type_name SEMICOLON
    (64) variable_declaration -> . identifier COLON simple_type_name SEMICOLON
    (65) variable_declaration -> . identifier COLON identifier SEMICOLON
    (66) variable_declaration -> . identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    IDENTIFIER      shift and go to state 8
    COLON           reduce using rule 1 (empty -> .)

    variable_declaration_list      shift and go to state 21
    variable_declaration           shift and go to state 22
    identifier_list                shift and go to state 23
    identifier                     shift and go to state 24
    empty                          shift and go to state 25

state 11

    (11) variable_declaration_part -> empty .

    FUNCTION        reduce using rule 11 (variable_declaration_part -> empty .)
    BEGIN           reduce using rule 11 (variable_declaration_part -> empty .)
    WHILE           reduce using rule 11 (variable_declaration_part -> empty .)
    IF              reduce using rule 11 (variable_declaration_part -> empty .)
    IDENTIFIER      reduce using rule 11 (variable_declaration_part -> empty .)
    INTEGER         reduce using rule 11 (variable_declaration_part -> empty .)
    REAL            reduce using rule 11 (variable_declaration_part -> empty .)
    CHAR            reduce using rule 11 (variable_declaration_part -> empty .)
    STRING          reduce using rule 11 (variable_declaration_part -> empty .)


state 12

    (6) type_definition_part -> TYPE type_definition_list .

    VAR             reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    FUNCTION        reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    BEGIN           reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    WHILE           reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    IF              reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    IDENTIFIER      reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    INTEGER         reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    REAL            reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    CHAR            reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)
    STRING          reduce using rule 6 (type_definition_part -> TYPE type_definition_list .)


state 13

    (8) type_definition_list -> type_definition .
    (9) type_definition_list -> type_definition . type_definition_list
    (8) type_definition_list -> . type_definition
    (9) type_definition_list -> . type_definition type_definition_list
    (20) type_definition -> . identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (75) identifier -> . IDENTIFIER

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    VAR             reduce using rule 8 (type_definition_list -> type_definition .)
    FUNCTION        reduce using rule 8 (type_definition_list -> type_definition .)
    BEGIN           reduce using rule 8 (type_definition_list -> type_definition .)
    WHILE           reduce using rule 8 (type_definition_list -> type_definition .)
    IF              reduce using rule 8 (type_definition_list -> type_definition .)
    INTEGER         reduce using rule 8 (type_definition_list -> type_definition .)
    REAL            reduce using rule 8 (type_definition_list -> type_definition .)
    CHAR            reduce using rule 8 (type_definition_list -> type_definition .)
    STRING          reduce using rule 8 (type_definition_list -> type_definition .)
    IDENTIFIER      shift and go to state 8

  ! IDENTIFIER      [ reduce using rule 8 (type_definition_list -> type_definition .) ]

    type_definition                shift and go to state 13
    type_definition_list           shift and go to state 26
    identifier                     shift and go to state 14

state 14

    (20) type_definition -> identifier . EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    EQ              shift and go to state 27


state 15

    (3) program_heading -> PROGRAM identifier SEMICOLON .

    TYPE            reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)
    VAR             reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)
    FUNCTION        reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)
    BEGIN           reduce using rule 3 (program_heading -> PROGRAM identifier SEMICOLON .)


state 16

    (2) program -> program_heading type_definition_part variable_declaration_part function_declaration_part . compound_statement
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT

    BEGIN           shift and go to state 29

    compound_statement             shift and go to state 28

state 17

    (12) function_declaration_part -> function_declaration . function_declaration_part
    (12) function_declaration_part -> . function_declaration function_declaration_part
    (13) function_declaration_part -> . empty
    (14) function_declaration -> . function_heading SEMICOLON block
    (1) empty -> .
    (15) function_heading -> . FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name

  ! shift/reduce conflict for FUNCTION resolved as shift
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    FUNCTION        shift and go to state 20

  ! FUNCTION        [ reduce using rule 1 (empty -> .) ]

    function_declaration           shift and go to state 17
    function_declaration_part      shift and go to state 30
    empty                          shift and go to state 18
    function_heading               shift and go to state 19

state 18

    (13) function_declaration_part -> empty .

    BEGIN           reduce using rule 13 (function_declaration_part -> empty .)
    WHILE           reduce using rule 13 (function_declaration_part -> empty .)
    IF              reduce using rule 13 (function_declaration_part -> empty .)
    IDENTIFIER      reduce using rule 13 (function_declaration_part -> empty .)
    INTEGER         reduce using rule 13 (function_declaration_part -> empty .)
    REAL            reduce using rule 13 (function_declaration_part -> empty .)
    CHAR            reduce using rule 13 (function_declaration_part -> empty .)
    STRING          reduce using rule 13 (function_declaration_part -> empty .)
    FUNCTION        reduce using rule 13 (function_declaration_part -> empty .)


state 19

    (14) function_declaration -> function_heading . SEMICOLON block

    SEMICOLON       shift and go to state 31


state 20

    (15) function_heading -> FUNCTION . identifier LPAREN parameters RPAREN COLON simple_type_name
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 32

state 21

    (10) variable_declaration_part -> VAR variable_declaration_list .

    FUNCTION        reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    BEGIN           reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    WHILE           reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    IF              reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    IDENTIFIER      reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    INTEGER         reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    REAL            reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    CHAR            reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)
    STRING          reduce using rule 10 (variable_declaration_part -> VAR variable_declaration_list .)


state 22

    (61) variable_declaration_list -> variable_declaration .
    (62) variable_declaration_list -> variable_declaration . variable_declaration_list
    (61) variable_declaration_list -> . variable_declaration
    (62) variable_declaration_list -> . variable_declaration variable_declaration_list
    (63) variable_declaration -> . identifier_list COLON simple_type_name SEMICOLON
    (64) variable_declaration -> . identifier COLON simple_type_name SEMICOLON
    (65) variable_declaration -> . identifier COLON identifier SEMICOLON
    (66) variable_declaration -> . identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    FUNCTION        reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    BEGIN           reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    WHILE           reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    IF              reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    INTEGER         reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    REAL            reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    CHAR            reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    STRING          reduce using rule 61 (variable_declaration_list -> variable_declaration .)
    IDENTIFIER      shift and go to state 8
    COLON           reduce using rule 1 (empty -> .)

  ! IDENTIFIER      [ reduce using rule 61 (variable_declaration_list -> variable_declaration .) ]

    variable_declaration           shift and go to state 22
    variable_declaration_list      shift and go to state 33
    identifier_list                shift and go to state 23
    identifier                     shift and go to state 24
    empty                          shift and go to state 25

state 23

    (63) variable_declaration -> identifier_list . COLON simple_type_name SEMICOLON

    COLON           shift and go to state 34


state 24

    (64) variable_declaration -> identifier . COLON simple_type_name SEMICOLON
    (65) variable_declaration -> identifier . COLON identifier SEMICOLON
    (66) variable_declaration -> identifier . COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (67) identifier_list -> identifier . COMMA identifier_list
    (68) identifier_list -> identifier . COMMA identifier

    COLON           shift and go to state 35
    COMMA           shift and go to state 36


state 25

    (69) identifier_list -> empty .

    COLON           reduce using rule 69 (identifier_list -> empty .)
    RPAREN          reduce using rule 69 (identifier_list -> empty .)


state 26

    (9) type_definition_list -> type_definition type_definition_list .

    VAR             reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    FUNCTION        reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    BEGIN           reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    WHILE           reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    IF              reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    IDENTIFIER      reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    INTEGER         reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    REAL            reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    CHAR            reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)
    STRING          reduce using rule 9 (type_definition_list -> type_definition type_definition_list .)


state 27

    (20) type_definition -> identifier EQ . ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    ARRAY           shift and go to state 37


state 28

    (2) program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement .

    $end            reduce using rule 2 (program -> program_heading type_definition_part variable_declaration_part function_declaration_part compound_statement .)


state 29

    (32) compound_statement -> BEGIN . statement_part END SEMICOLON
    (33) compound_statement -> BEGIN . statement_part END DOT
    (21) statement_part -> . compound_statement
    (22) statement_part -> . assignment_list
    (23) statement_part -> . while_statement
    (24) statement_part -> . if_else_statement
    (25) statement_part -> . expression
    (26) statement_part -> . empty
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT
    (34) assignment_list -> . assignment statement_part
    (27) while_statement -> . WHILE expression DO statement_part
    (30) if_else_statement -> . IF expression THEN statement_part
    (31) if_else_statement -> . IF expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (35) assignment -> . identifier ASSIGNMENT expression ending
    (36) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

    BEGIN           shift and go to state 29
    WHILE           shift and go to state 46
    IF              shift and go to state 47
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58

    statement_part                 shift and go to state 38
    compound_statement             shift and go to state 39
    assignment_list                shift and go to state 40
    while_statement                shift and go to state 41
    if_else_statement              shift and go to state 42
    expression                     shift and go to state 43
    empty                          shift and go to state 44
    assignment                     shift and go to state 45
    term                           shift and go to state 48
    identifier                     shift and go to state 49
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 30

    (12) function_declaration_part -> function_declaration function_declaration_part .

    BEGIN           reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    WHILE           reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    IF              reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    IDENTIFIER      reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    INTEGER         reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    REAL            reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    CHAR            reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    STRING          reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)
    FUNCTION        reduce using rule 12 (function_declaration_part -> function_declaration function_declaration_part .)


state 31

    (14) function_declaration -> function_heading SEMICOLON . block
    (5) block -> . declaration_part statement_part
    (4) declaration_part -> . type_definition_part variable_declaration_part function_declaration_part
    (6) type_definition_part -> . TYPE type_definition_list
    (7) type_definition_part -> . empty
    (1) empty -> .

    TYPE            shift and go to state 5
    VAR             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)

    block                          shift and go to state 59
    declaration_part               shift and go to state 60
    type_definition_part           shift and go to state 61
    empty                          shift and go to state 6

state 32

    (15) function_heading -> FUNCTION identifier . LPAREN parameters RPAREN COLON simple_type_name

    LPAREN          shift and go to state 62


state 33

    (62) variable_declaration_list -> variable_declaration variable_declaration_list .

    FUNCTION        reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    BEGIN           reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    WHILE           reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    IF              reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    IDENTIFIER      reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    INTEGER         reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    REAL            reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    CHAR            reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    STRING          reduce using rule 62 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 34

    (63) variable_declaration -> identifier_list COLON . simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 64
    SCHAR           shift and go to state 65
    SREAL           shift and go to state 66
    SINTEGER        shift and go to state 67
    IDENTIFIER      shift and go to state 8

    simple_type_name               shift and go to state 63
    identifier                     shift and go to state 68

state 35

    (64) variable_declaration -> identifier COLON . simple_type_name SEMICOLON
    (65) variable_declaration -> identifier COLON . identifier SEMICOLON
    (66) variable_declaration -> identifier COLON . ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    ARRAY           shift and go to state 71
    SSTRING         shift and go to state 64
    SCHAR           shift and go to state 65
    SREAL           shift and go to state 66
    SINTEGER        shift and go to state 67
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 69
    simple_type_name               shift and go to state 70

state 36

    (67) identifier_list -> identifier COMMA . identifier_list
    (68) identifier_list -> identifier COMMA . identifier
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    IDENTIFIER      shift and go to state 8
    COLON           reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 72
    identifier_list                shift and go to state 73
    empty                          shift and go to state 25

state 37

    (20) type_definition -> identifier EQ ARRAY . LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    LPARENARR       shift and go to state 74


state 38

    (32) compound_statement -> BEGIN statement_part . END SEMICOLON
    (33) compound_statement -> BEGIN statement_part . END DOT

    END             shift and go to state 75


state 39

    (21) statement_part -> compound_statement .

    END             reduce using rule 21 (statement_part -> compound_statement .)
    BEGIN           reduce using rule 21 (statement_part -> compound_statement .)
    WHILE           reduce using rule 21 (statement_part -> compound_statement .)
    IF              reduce using rule 21 (statement_part -> compound_statement .)
    IDENTIFIER      reduce using rule 21 (statement_part -> compound_statement .)
    INTEGER         reduce using rule 21 (statement_part -> compound_statement .)
    REAL            reduce using rule 21 (statement_part -> compound_statement .)
    CHAR            reduce using rule 21 (statement_part -> compound_statement .)
    STRING          reduce using rule 21 (statement_part -> compound_statement .)
    FUNCTION        reduce using rule 21 (statement_part -> compound_statement .)
    ELSE            reduce using rule 21 (statement_part -> compound_statement .)


state 40

    (22) statement_part -> assignment_list .

    END             reduce using rule 22 (statement_part -> assignment_list .)
    BEGIN           reduce using rule 22 (statement_part -> assignment_list .)
    WHILE           reduce using rule 22 (statement_part -> assignment_list .)
    IF              reduce using rule 22 (statement_part -> assignment_list .)
    IDENTIFIER      reduce using rule 22 (statement_part -> assignment_list .)
    INTEGER         reduce using rule 22 (statement_part -> assignment_list .)
    REAL            reduce using rule 22 (statement_part -> assignment_list .)
    CHAR            reduce using rule 22 (statement_part -> assignment_list .)
    STRING          reduce using rule 22 (statement_part -> assignment_list .)
    FUNCTION        reduce using rule 22 (statement_part -> assignment_list .)
    ELSE            reduce using rule 22 (statement_part -> assignment_list .)


state 41

    (23) statement_part -> while_statement .

    END             reduce using rule 23 (statement_part -> while_statement .)
    BEGIN           reduce using rule 23 (statement_part -> while_statement .)
    WHILE           reduce using rule 23 (statement_part -> while_statement .)
    IF              reduce using rule 23 (statement_part -> while_statement .)
    IDENTIFIER      reduce using rule 23 (statement_part -> while_statement .)
    INTEGER         reduce using rule 23 (statement_part -> while_statement .)
    REAL            reduce using rule 23 (statement_part -> while_statement .)
    CHAR            reduce using rule 23 (statement_part -> while_statement .)
    STRING          reduce using rule 23 (statement_part -> while_statement .)
    FUNCTION        reduce using rule 23 (statement_part -> while_statement .)
    ELSE            reduce using rule 23 (statement_part -> while_statement .)


state 42

    (24) statement_part -> if_else_statement .

    END             reduce using rule 24 (statement_part -> if_else_statement .)
    BEGIN           reduce using rule 24 (statement_part -> if_else_statement .)
    WHILE           reduce using rule 24 (statement_part -> if_else_statement .)
    IF              reduce using rule 24 (statement_part -> if_else_statement .)
    IDENTIFIER      reduce using rule 24 (statement_part -> if_else_statement .)
    INTEGER         reduce using rule 24 (statement_part -> if_else_statement .)
    REAL            reduce using rule 24 (statement_part -> if_else_statement .)
    CHAR            reduce using rule 24 (statement_part -> if_else_statement .)
    STRING          reduce using rule 24 (statement_part -> if_else_statement .)
    FUNCTION        reduce using rule 24 (statement_part -> if_else_statement .)
    ELSE            reduce using rule 24 (statement_part -> if_else_statement .)


state 43

    (25) statement_part -> expression .
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

    END             reduce using rule 25 (statement_part -> expression .)
    BEGIN           reduce using rule 25 (statement_part -> expression .)
    WHILE           reduce using rule 25 (statement_part -> expression .)
    IF              reduce using rule 25 (statement_part -> expression .)
    IDENTIFIER      reduce using rule 25 (statement_part -> expression .)
    INTEGER         reduce using rule 25 (statement_part -> expression .)
    REAL            reduce using rule 25 (statement_part -> expression .)
    CHAR            reduce using rule 25 (statement_part -> expression .)
    STRING          reduce using rule 25 (statement_part -> expression .)
    FUNCTION        reduce using rule 25 (statement_part -> expression .)
    ELSE            reduce using rule 25 (statement_part -> expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    EQ              shift and go to state 80
    NEQ             shift and go to state 81
    GT              shift and go to state 82
    LT              shift and go to state 83
    GTE             shift and go to state 84
    LTE             shift and go to state 85
    AND             shift and go to state 86
    OR              shift and go to state 87

    sign                           shift and go to state 76
    and_or                         shift and go to state 77

state 44

    (26) statement_part -> empty .

    END             reduce using rule 26 (statement_part -> empty .)
    BEGIN           reduce using rule 26 (statement_part -> empty .)
    WHILE           reduce using rule 26 (statement_part -> empty .)
    IF              reduce using rule 26 (statement_part -> empty .)
    IDENTIFIER      reduce using rule 26 (statement_part -> empty .)
    INTEGER         reduce using rule 26 (statement_part -> empty .)
    REAL            reduce using rule 26 (statement_part -> empty .)
    CHAR            reduce using rule 26 (statement_part -> empty .)
    STRING          reduce using rule 26 (statement_part -> empty .)
    FUNCTION        reduce using rule 26 (statement_part -> empty .)
    ELSE            reduce using rule 26 (statement_part -> empty .)


state 45

    (34) assignment_list -> assignment . statement_part
    (21) statement_part -> . compound_statement
    (22) statement_part -> . assignment_list
    (23) statement_part -> . while_statement
    (24) statement_part -> . if_else_statement
    (25) statement_part -> . expression
    (26) statement_part -> . empty
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT
    (34) assignment_list -> . assignment statement_part
    (27) while_statement -> . WHILE expression DO statement_part
    (30) if_else_statement -> . IF expression THEN statement_part
    (31) if_else_statement -> . IF expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (35) assignment -> . identifier ASSIGNMENT expression ending
    (36) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 46
    IF              shift and go to state 47
    END             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    assignment                     shift and go to state 45
    statement_part                 shift and go to state 88
    compound_statement             shift and go to state 39
    assignment_list                shift and go to state 40
    while_statement                shift and go to state 41
    if_else_statement              shift and go to state 42
    expression                     shift and go to state 43
    empty                          shift and go to state 44
    term                           shift and go to state 48
    identifier                     shift and go to state 49
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 46

    (27) while_statement -> WHILE . expression DO statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    expression                     shift and go to state 89
    term                           shift and go to state 48
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54
    identifier                     shift and go to state 90

state 47

    (30) if_else_statement -> IF . expression THEN statement_part
    (31) if_else_statement -> IF . expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    expression                     shift and go to state 91
    term                           shift and go to state 48
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54
    identifier                     shift and go to state 90

state 48

    (37) expression -> term .

    PLUS            reduce using rule 37 (expression -> term .)
    MINUS           reduce using rule 37 (expression -> term .)
    EQ              reduce using rule 37 (expression -> term .)
    NEQ             reduce using rule 37 (expression -> term .)
    GT              reduce using rule 37 (expression -> term .)
    LT              reduce using rule 37 (expression -> term .)
    GTE             reduce using rule 37 (expression -> term .)
    LTE             reduce using rule 37 (expression -> term .)
    AND             reduce using rule 37 (expression -> term .)
    OR              reduce using rule 37 (expression -> term .)
    END             reduce using rule 37 (expression -> term .)
    BEGIN           reduce using rule 37 (expression -> term .)
    WHILE           reduce using rule 37 (expression -> term .)
    IF              reduce using rule 37 (expression -> term .)
    IDENTIFIER      reduce using rule 37 (expression -> term .)
    INTEGER         reduce using rule 37 (expression -> term .)
    REAL            reduce using rule 37 (expression -> term .)
    CHAR            reduce using rule 37 (expression -> term .)
    STRING          reduce using rule 37 (expression -> term .)
    FUNCTION        reduce using rule 37 (expression -> term .)
    ELSE            reduce using rule 37 (expression -> term .)
    DO              reduce using rule 37 (expression -> term .)
    THEN            reduce using rule 37 (expression -> term .)
    SEMICOLON       reduce using rule 37 (expression -> term .)


state 49

    (35) assignment -> identifier . ASSIGNMENT expression ending
    (36) assignment -> identifier . LPARENARR term RPARENARR ASSIGNMENT expression ending
    (55) term -> identifier .
    (60) function_call -> identifier . LPAREN identifier_list RPAREN

    ASSIGNMENT      shift and go to state 92
    LPARENARR       shift and go to state 93
    PLUS            reduce using rule 55 (term -> identifier .)
    MINUS           reduce using rule 55 (term -> identifier .)
    EQ              reduce using rule 55 (term -> identifier .)
    NEQ             reduce using rule 55 (term -> identifier .)
    GT              reduce using rule 55 (term -> identifier .)
    LT              reduce using rule 55 (term -> identifier .)
    GTE             reduce using rule 55 (term -> identifier .)
    LTE             reduce using rule 55 (term -> identifier .)
    AND             reduce using rule 55 (term -> identifier .)
    OR              reduce using rule 55 (term -> identifier .)
    END             reduce using rule 55 (term -> identifier .)
    BEGIN           reduce using rule 55 (term -> identifier .)
    WHILE           reduce using rule 55 (term -> identifier .)
    IF              reduce using rule 55 (term -> identifier .)
    IDENTIFIER      reduce using rule 55 (term -> identifier .)
    INTEGER         reduce using rule 55 (term -> identifier .)
    REAL            reduce using rule 55 (term -> identifier .)
    CHAR            reduce using rule 55 (term -> identifier .)
    STRING          reduce using rule 55 (term -> identifier .)
    FUNCTION        reduce using rule 55 (term -> identifier .)
    ELSE            reduce using rule 55 (term -> identifier .)
    LPAREN          shift and go to state 94


state 50

    (50) term -> integer .

    PLUS            reduce using rule 50 (term -> integer .)
    MINUS           reduce using rule 50 (term -> integer .)
    EQ              reduce using rule 50 (term -> integer .)
    NEQ             reduce using rule 50 (term -> integer .)
    GT              reduce using rule 50 (term -> integer .)
    LT              reduce using rule 50 (term -> integer .)
    GTE             reduce using rule 50 (term -> integer .)
    LTE             reduce using rule 50 (term -> integer .)
    AND             reduce using rule 50 (term -> integer .)
    OR              reduce using rule 50 (term -> integer .)
    END             reduce using rule 50 (term -> integer .)
    BEGIN           reduce using rule 50 (term -> integer .)
    WHILE           reduce using rule 50 (term -> integer .)
    IF              reduce using rule 50 (term -> integer .)
    IDENTIFIER      reduce using rule 50 (term -> integer .)
    INTEGER         reduce using rule 50 (term -> integer .)
    REAL            reduce using rule 50 (term -> integer .)
    CHAR            reduce using rule 50 (term -> integer .)
    STRING          reduce using rule 50 (term -> integer .)
    FUNCTION        reduce using rule 50 (term -> integer .)
    ELSE            reduce using rule 50 (term -> integer .)
    DO              reduce using rule 50 (term -> integer .)
    THEN            reduce using rule 50 (term -> integer .)
    SEMICOLON       reduce using rule 50 (term -> integer .)
    RPARENARR       reduce using rule 50 (term -> integer .)


state 51

    (51) term -> real .

    PLUS            reduce using rule 51 (term -> real .)
    MINUS           reduce using rule 51 (term -> real .)
    EQ              reduce using rule 51 (term -> real .)
    NEQ             reduce using rule 51 (term -> real .)
    GT              reduce using rule 51 (term -> real .)
    LT              reduce using rule 51 (term -> real .)
    GTE             reduce using rule 51 (term -> real .)
    LTE             reduce using rule 51 (term -> real .)
    AND             reduce using rule 51 (term -> real .)
    OR              reduce using rule 51 (term -> real .)
    END             reduce using rule 51 (term -> real .)
    BEGIN           reduce using rule 51 (term -> real .)
    WHILE           reduce using rule 51 (term -> real .)
    IF              reduce using rule 51 (term -> real .)
    IDENTIFIER      reduce using rule 51 (term -> real .)
    INTEGER         reduce using rule 51 (term -> real .)
    REAL            reduce using rule 51 (term -> real .)
    CHAR            reduce using rule 51 (term -> real .)
    STRING          reduce using rule 51 (term -> real .)
    FUNCTION        reduce using rule 51 (term -> real .)
    ELSE            reduce using rule 51 (term -> real .)
    DO              reduce using rule 51 (term -> real .)
    THEN            reduce using rule 51 (term -> real .)
    SEMICOLON       reduce using rule 51 (term -> real .)
    RPARENARR       reduce using rule 51 (term -> real .)


state 52

    (52) term -> char .

    PLUS            reduce using rule 52 (term -> char .)
    MINUS           reduce using rule 52 (term -> char .)
    EQ              reduce using rule 52 (term -> char .)
    NEQ             reduce using rule 52 (term -> char .)
    GT              reduce using rule 52 (term -> char .)
    LT              reduce using rule 52 (term -> char .)
    GTE             reduce using rule 52 (term -> char .)
    LTE             reduce using rule 52 (term -> char .)
    AND             reduce using rule 52 (term -> char .)
    OR              reduce using rule 52 (term -> char .)
    END             reduce using rule 52 (term -> char .)
    BEGIN           reduce using rule 52 (term -> char .)
    WHILE           reduce using rule 52 (term -> char .)
    IF              reduce using rule 52 (term -> char .)
    IDENTIFIER      reduce using rule 52 (term -> char .)
    INTEGER         reduce using rule 52 (term -> char .)
    REAL            reduce using rule 52 (term -> char .)
    CHAR            reduce using rule 52 (term -> char .)
    STRING          reduce using rule 52 (term -> char .)
    FUNCTION        reduce using rule 52 (term -> char .)
    ELSE            reduce using rule 52 (term -> char .)
    DO              reduce using rule 52 (term -> char .)
    THEN            reduce using rule 52 (term -> char .)
    SEMICOLON       reduce using rule 52 (term -> char .)
    RPARENARR       reduce using rule 52 (term -> char .)


state 53

    (53) term -> string .

    PLUS            reduce using rule 53 (term -> string .)
    MINUS           reduce using rule 53 (term -> string .)
    EQ              reduce using rule 53 (term -> string .)
    NEQ             reduce using rule 53 (term -> string .)
    GT              reduce using rule 53 (term -> string .)
    LT              reduce using rule 53 (term -> string .)
    GTE             reduce using rule 53 (term -> string .)
    LTE             reduce using rule 53 (term -> string .)
    AND             reduce using rule 53 (term -> string .)
    OR              reduce using rule 53 (term -> string .)
    END             reduce using rule 53 (term -> string .)
    BEGIN           reduce using rule 53 (term -> string .)
    WHILE           reduce using rule 53 (term -> string .)
    IF              reduce using rule 53 (term -> string .)
    IDENTIFIER      reduce using rule 53 (term -> string .)
    INTEGER         reduce using rule 53 (term -> string .)
    REAL            reduce using rule 53 (term -> string .)
    CHAR            reduce using rule 53 (term -> string .)
    STRING          reduce using rule 53 (term -> string .)
    FUNCTION        reduce using rule 53 (term -> string .)
    ELSE            reduce using rule 53 (term -> string .)
    DO              reduce using rule 53 (term -> string .)
    THEN            reduce using rule 53 (term -> string .)
    SEMICOLON       reduce using rule 53 (term -> string .)
    RPARENARR       reduce using rule 53 (term -> string .)


state 54

    (54) term -> function_call .

    PLUS            reduce using rule 54 (term -> function_call .)
    MINUS           reduce using rule 54 (term -> function_call .)
    EQ              reduce using rule 54 (term -> function_call .)
    NEQ             reduce using rule 54 (term -> function_call .)
    GT              reduce using rule 54 (term -> function_call .)
    LT              reduce using rule 54 (term -> function_call .)
    GTE             reduce using rule 54 (term -> function_call .)
    LTE             reduce using rule 54 (term -> function_call .)
    AND             reduce using rule 54 (term -> function_call .)
    OR              reduce using rule 54 (term -> function_call .)
    END             reduce using rule 54 (term -> function_call .)
    BEGIN           reduce using rule 54 (term -> function_call .)
    WHILE           reduce using rule 54 (term -> function_call .)
    IF              reduce using rule 54 (term -> function_call .)
    IDENTIFIER      reduce using rule 54 (term -> function_call .)
    INTEGER         reduce using rule 54 (term -> function_call .)
    REAL            reduce using rule 54 (term -> function_call .)
    CHAR            reduce using rule 54 (term -> function_call .)
    STRING          reduce using rule 54 (term -> function_call .)
    FUNCTION        reduce using rule 54 (term -> function_call .)
    ELSE            reduce using rule 54 (term -> function_call .)
    DO              reduce using rule 54 (term -> function_call .)
    THEN            reduce using rule 54 (term -> function_call .)
    SEMICOLON       reduce using rule 54 (term -> function_call .)
    RPARENARR       reduce using rule 54 (term -> function_call .)


state 55

    (56) integer -> INTEGER .

    PLUS            reduce using rule 56 (integer -> INTEGER .)
    MINUS           reduce using rule 56 (integer -> INTEGER .)
    EQ              reduce using rule 56 (integer -> INTEGER .)
    NEQ             reduce using rule 56 (integer -> INTEGER .)
    GT              reduce using rule 56 (integer -> INTEGER .)
    LT              reduce using rule 56 (integer -> INTEGER .)
    GTE             reduce using rule 56 (integer -> INTEGER .)
    LTE             reduce using rule 56 (integer -> INTEGER .)
    AND             reduce using rule 56 (integer -> INTEGER .)
    OR              reduce using rule 56 (integer -> INTEGER .)
    END             reduce using rule 56 (integer -> INTEGER .)
    BEGIN           reduce using rule 56 (integer -> INTEGER .)
    WHILE           reduce using rule 56 (integer -> INTEGER .)
    IF              reduce using rule 56 (integer -> INTEGER .)
    IDENTIFIER      reduce using rule 56 (integer -> INTEGER .)
    INTEGER         reduce using rule 56 (integer -> INTEGER .)
    REAL            reduce using rule 56 (integer -> INTEGER .)
    CHAR            reduce using rule 56 (integer -> INTEGER .)
    STRING          reduce using rule 56 (integer -> INTEGER .)
    FUNCTION        reduce using rule 56 (integer -> INTEGER .)
    ELSE            reduce using rule 56 (integer -> INTEGER .)
    DO              reduce using rule 56 (integer -> INTEGER .)
    THEN            reduce using rule 56 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 56 (integer -> INTEGER .)
    RPARENARR       reduce using rule 56 (integer -> INTEGER .)


state 56

    (57) real -> REAL .

    PLUS            reduce using rule 57 (real -> REAL .)
    MINUS           reduce using rule 57 (real -> REAL .)
    EQ              reduce using rule 57 (real -> REAL .)
    NEQ             reduce using rule 57 (real -> REAL .)
    GT              reduce using rule 57 (real -> REAL .)
    LT              reduce using rule 57 (real -> REAL .)
    GTE             reduce using rule 57 (real -> REAL .)
    LTE             reduce using rule 57 (real -> REAL .)
    AND             reduce using rule 57 (real -> REAL .)
    OR              reduce using rule 57 (real -> REAL .)
    END             reduce using rule 57 (real -> REAL .)
    BEGIN           reduce using rule 57 (real -> REAL .)
    WHILE           reduce using rule 57 (real -> REAL .)
    IF              reduce using rule 57 (real -> REAL .)
    IDENTIFIER      reduce using rule 57 (real -> REAL .)
    INTEGER         reduce using rule 57 (real -> REAL .)
    REAL            reduce using rule 57 (real -> REAL .)
    CHAR            reduce using rule 57 (real -> REAL .)
    STRING          reduce using rule 57 (real -> REAL .)
    FUNCTION        reduce using rule 57 (real -> REAL .)
    ELSE            reduce using rule 57 (real -> REAL .)
    DO              reduce using rule 57 (real -> REAL .)
    THEN            reduce using rule 57 (real -> REAL .)
    SEMICOLON       reduce using rule 57 (real -> REAL .)
    RPARENARR       reduce using rule 57 (real -> REAL .)


state 57

    (59) char -> CHAR .

    PLUS            reduce using rule 59 (char -> CHAR .)
    MINUS           reduce using rule 59 (char -> CHAR .)
    EQ              reduce using rule 59 (char -> CHAR .)
    NEQ             reduce using rule 59 (char -> CHAR .)
    GT              reduce using rule 59 (char -> CHAR .)
    LT              reduce using rule 59 (char -> CHAR .)
    GTE             reduce using rule 59 (char -> CHAR .)
    LTE             reduce using rule 59 (char -> CHAR .)
    AND             reduce using rule 59 (char -> CHAR .)
    OR              reduce using rule 59 (char -> CHAR .)
    END             reduce using rule 59 (char -> CHAR .)
    BEGIN           reduce using rule 59 (char -> CHAR .)
    WHILE           reduce using rule 59 (char -> CHAR .)
    IF              reduce using rule 59 (char -> CHAR .)
    IDENTIFIER      reduce using rule 59 (char -> CHAR .)
    INTEGER         reduce using rule 59 (char -> CHAR .)
    REAL            reduce using rule 59 (char -> CHAR .)
    CHAR            reduce using rule 59 (char -> CHAR .)
    STRING          reduce using rule 59 (char -> CHAR .)
    FUNCTION        reduce using rule 59 (char -> CHAR .)
    ELSE            reduce using rule 59 (char -> CHAR .)
    DO              reduce using rule 59 (char -> CHAR .)
    THEN            reduce using rule 59 (char -> CHAR .)
    SEMICOLON       reduce using rule 59 (char -> CHAR .)
    RPARENARR       reduce using rule 59 (char -> CHAR .)


state 58

    (58) string -> STRING .

    PLUS            reduce using rule 58 (string -> STRING .)
    MINUS           reduce using rule 58 (string -> STRING .)
    EQ              reduce using rule 58 (string -> STRING .)
    NEQ             reduce using rule 58 (string -> STRING .)
    GT              reduce using rule 58 (string -> STRING .)
    LT              reduce using rule 58 (string -> STRING .)
    GTE             reduce using rule 58 (string -> STRING .)
    LTE             reduce using rule 58 (string -> STRING .)
    AND             reduce using rule 58 (string -> STRING .)
    OR              reduce using rule 58 (string -> STRING .)
    END             reduce using rule 58 (string -> STRING .)
    BEGIN           reduce using rule 58 (string -> STRING .)
    WHILE           reduce using rule 58 (string -> STRING .)
    IF              reduce using rule 58 (string -> STRING .)
    IDENTIFIER      reduce using rule 58 (string -> STRING .)
    INTEGER         reduce using rule 58 (string -> STRING .)
    REAL            reduce using rule 58 (string -> STRING .)
    CHAR            reduce using rule 58 (string -> STRING .)
    STRING          reduce using rule 58 (string -> STRING .)
    FUNCTION        reduce using rule 58 (string -> STRING .)
    ELSE            reduce using rule 58 (string -> STRING .)
    DO              reduce using rule 58 (string -> STRING .)
    THEN            reduce using rule 58 (string -> STRING .)
    SEMICOLON       reduce using rule 58 (string -> STRING .)
    RPARENARR       reduce using rule 58 (string -> STRING .)


state 59

    (14) function_declaration -> function_heading SEMICOLON block .

    FUNCTION        reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    BEGIN           reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    WHILE           reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    IF              reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    IDENTIFIER      reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    INTEGER         reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    REAL            reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    CHAR            reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)
    STRING          reduce using rule 14 (function_declaration -> function_heading SEMICOLON block .)


state 60

    (5) block -> declaration_part . statement_part
    (21) statement_part -> . compound_statement
    (22) statement_part -> . assignment_list
    (23) statement_part -> . while_statement
    (24) statement_part -> . if_else_statement
    (25) statement_part -> . expression
    (26) statement_part -> . empty
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT
    (34) assignment_list -> . assignment statement_part
    (27) while_statement -> . WHILE expression DO statement_part
    (30) if_else_statement -> . IF expression THEN statement_part
    (31) if_else_statement -> . IF expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (35) assignment -> . identifier ASSIGNMENT expression ending
    (36) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 46
    IF              shift and go to state 47
    FUNCTION        reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    statement_part                 shift and go to state 95
    compound_statement             shift and go to state 39
    assignment_list                shift and go to state 40
    while_statement                shift and go to state 41
    if_else_statement              shift and go to state 42
    expression                     shift and go to state 43
    empty                          shift and go to state 44
    assignment                     shift and go to state 45
    term                           shift and go to state 48
    identifier                     shift and go to state 49
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 61

    (4) declaration_part -> type_definition_part . variable_declaration_part function_declaration_part
    (10) variable_declaration_part -> . VAR variable_declaration_list
    (11) variable_declaration_part -> . empty
    (1) empty -> .

    VAR             shift and go to state 10
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)

    variable_declaration_part      shift and go to state 96
    empty                          shift and go to state 11

state 62

    (15) function_heading -> FUNCTION identifier LPAREN . parameters RPAREN COLON simple_type_name
    (16) parameters -> . names_list COLON simple_type_name
    (17) parameters -> . names_list COLON simple_type_name SEMICOLON parameters
    (18) names_list -> . identifier
    (19) names_list -> . identifier COMMA names_list
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 97
    parameters                     shift and go to state 98
    names_list                     shift and go to state 99

state 63

    (63) variable_declaration -> identifier_list COLON simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 100


state 64

    (70) simple_type_name -> SSTRING .

    SEMICOLON       reduce using rule 70 (simple_type_name -> SSTRING .)
    RPAREN          reduce using rule 70 (simple_type_name -> SSTRING .)


state 65

    (71) simple_type_name -> SCHAR .

    SEMICOLON       reduce using rule 71 (simple_type_name -> SCHAR .)
    RPAREN          reduce using rule 71 (simple_type_name -> SCHAR .)


state 66

    (72) simple_type_name -> SREAL .

    SEMICOLON       reduce using rule 72 (simple_type_name -> SREAL .)
    RPAREN          reduce using rule 72 (simple_type_name -> SREAL .)


state 67

    (73) simple_type_name -> SINTEGER .

    SEMICOLON       reduce using rule 73 (simple_type_name -> SINTEGER .)
    RPAREN          reduce using rule 73 (simple_type_name -> SINTEGER .)


state 68

    (74) simple_type_name -> identifier .

    SEMICOLON       reduce using rule 74 (simple_type_name -> identifier .)
    RPAREN          reduce using rule 74 (simple_type_name -> identifier .)


state 69

    (65) variable_declaration -> identifier COLON identifier . SEMICOLON
    (74) simple_type_name -> identifier .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 101

  ! SEMICOLON       [ reduce using rule 74 (simple_type_name -> identifier .) ]


state 70

    (64) variable_declaration -> identifier COLON simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 102


state 71

    (66) variable_declaration -> identifier COLON ARRAY . LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    LPARENARR       shift and go to state 103


state 72

    (68) identifier_list -> identifier COMMA identifier .
    (67) identifier_list -> identifier . COMMA identifier_list
    (68) identifier_list -> identifier . COMMA identifier

    COLON           reduce using rule 68 (identifier_list -> identifier COMMA identifier .)
    RPAREN          reduce using rule 68 (identifier_list -> identifier COMMA identifier .)
    COMMA           shift and go to state 36


state 73

    (67) identifier_list -> identifier COMMA identifier_list .

    COLON           reduce using rule 67 (identifier_list -> identifier COMMA identifier_list .)
    RPAREN          reduce using rule 67 (identifier_list -> identifier COMMA identifier_list .)


state 74

    (20) type_definition -> identifier EQ ARRAY LPARENARR . INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 104


state 75

    (32) compound_statement -> BEGIN statement_part END . SEMICOLON
    (33) compound_statement -> BEGIN statement_part END . DOT

    SEMICOLON       shift and go to state 105
    DOT             shift and go to state 106


state 76

    (38) expression -> expression sign . term
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    term                           shift and go to state 107
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54
    identifier                     shift and go to state 90

state 77

    (39) expression -> expression and_or . expression
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    expression                     shift and go to state 108
    term                           shift and go to state 48
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54
    identifier                     shift and go to state 90

state 78

    (42) sign -> PLUS .

    INTEGER         reduce using rule 42 (sign -> PLUS .)
    REAL            reduce using rule 42 (sign -> PLUS .)
    CHAR            reduce using rule 42 (sign -> PLUS .)
    STRING          reduce using rule 42 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 42 (sign -> PLUS .)


state 79

    (43) sign -> MINUS .

    INTEGER         reduce using rule 43 (sign -> MINUS .)
    REAL            reduce using rule 43 (sign -> MINUS .)
    CHAR            reduce using rule 43 (sign -> MINUS .)
    STRING          reduce using rule 43 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 43 (sign -> MINUS .)


state 80

    (44) sign -> EQ .

    INTEGER         reduce using rule 44 (sign -> EQ .)
    REAL            reduce using rule 44 (sign -> EQ .)
    CHAR            reduce using rule 44 (sign -> EQ .)
    STRING          reduce using rule 44 (sign -> EQ .)
    IDENTIFIER      reduce using rule 44 (sign -> EQ .)


state 81

    (45) sign -> NEQ .

    INTEGER         reduce using rule 45 (sign -> NEQ .)
    REAL            reduce using rule 45 (sign -> NEQ .)
    CHAR            reduce using rule 45 (sign -> NEQ .)
    STRING          reduce using rule 45 (sign -> NEQ .)
    IDENTIFIER      reduce using rule 45 (sign -> NEQ .)


state 82

    (46) sign -> GT .

    INTEGER         reduce using rule 46 (sign -> GT .)
    REAL            reduce using rule 46 (sign -> GT .)
    CHAR            reduce using rule 46 (sign -> GT .)
    STRING          reduce using rule 46 (sign -> GT .)
    IDENTIFIER      reduce using rule 46 (sign -> GT .)


state 83

    (47) sign -> LT .

    INTEGER         reduce using rule 47 (sign -> LT .)
    REAL            reduce using rule 47 (sign -> LT .)
    CHAR            reduce using rule 47 (sign -> LT .)
    STRING          reduce using rule 47 (sign -> LT .)
    IDENTIFIER      reduce using rule 47 (sign -> LT .)


state 84

    (48) sign -> GTE .

    INTEGER         reduce using rule 48 (sign -> GTE .)
    REAL            reduce using rule 48 (sign -> GTE .)
    CHAR            reduce using rule 48 (sign -> GTE .)
    STRING          reduce using rule 48 (sign -> GTE .)
    IDENTIFIER      reduce using rule 48 (sign -> GTE .)


state 85

    (49) sign -> LTE .

    INTEGER         reduce using rule 49 (sign -> LTE .)
    REAL            reduce using rule 49 (sign -> LTE .)
    CHAR            reduce using rule 49 (sign -> LTE .)
    STRING          reduce using rule 49 (sign -> LTE .)
    IDENTIFIER      reduce using rule 49 (sign -> LTE .)


state 86

    (40) and_or -> AND .

    INTEGER         reduce using rule 40 (and_or -> AND .)
    REAL            reduce using rule 40 (and_or -> AND .)
    CHAR            reduce using rule 40 (and_or -> AND .)
    STRING          reduce using rule 40 (and_or -> AND .)
    IDENTIFIER      reduce using rule 40 (and_or -> AND .)


state 87

    (41) and_or -> OR .

    INTEGER         reduce using rule 41 (and_or -> OR .)
    REAL            reduce using rule 41 (and_or -> OR .)
    CHAR            reduce using rule 41 (and_or -> OR .)
    STRING          reduce using rule 41 (and_or -> OR .)
    IDENTIFIER      reduce using rule 41 (and_or -> OR .)


state 88

    (34) assignment_list -> assignment statement_part .

    END             reduce using rule 34 (assignment_list -> assignment statement_part .)
    BEGIN           reduce using rule 34 (assignment_list -> assignment statement_part .)
    WHILE           reduce using rule 34 (assignment_list -> assignment statement_part .)
    IF              reduce using rule 34 (assignment_list -> assignment statement_part .)
    IDENTIFIER      reduce using rule 34 (assignment_list -> assignment statement_part .)
    INTEGER         reduce using rule 34 (assignment_list -> assignment statement_part .)
    REAL            reduce using rule 34 (assignment_list -> assignment statement_part .)
    CHAR            reduce using rule 34 (assignment_list -> assignment statement_part .)
    STRING          reduce using rule 34 (assignment_list -> assignment statement_part .)
    FUNCTION        reduce using rule 34 (assignment_list -> assignment statement_part .)
    ELSE            reduce using rule 34 (assignment_list -> assignment statement_part .)


state 89

    (27) while_statement -> WHILE expression . DO statement_part
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

    DO              shift and go to state 109
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    EQ              shift and go to state 80
    NEQ             shift and go to state 81
    GT              shift and go to state 82
    LT              shift and go to state 83
    GTE             shift and go to state 84
    LTE             shift and go to state 85
    AND             shift and go to state 86
    OR              shift and go to state 87

    sign                           shift and go to state 76
    and_or                         shift and go to state 77

state 90

    (55) term -> identifier .
    (60) function_call -> identifier . LPAREN identifier_list RPAREN

    DO              reduce using rule 55 (term -> identifier .)
    PLUS            reduce using rule 55 (term -> identifier .)
    MINUS           reduce using rule 55 (term -> identifier .)
    EQ              reduce using rule 55 (term -> identifier .)
    NEQ             reduce using rule 55 (term -> identifier .)
    GT              reduce using rule 55 (term -> identifier .)
    LT              reduce using rule 55 (term -> identifier .)
    GTE             reduce using rule 55 (term -> identifier .)
    LTE             reduce using rule 55 (term -> identifier .)
    AND             reduce using rule 55 (term -> identifier .)
    OR              reduce using rule 55 (term -> identifier .)
    THEN            reduce using rule 55 (term -> identifier .)
    END             reduce using rule 55 (term -> identifier .)
    BEGIN           reduce using rule 55 (term -> identifier .)
    WHILE           reduce using rule 55 (term -> identifier .)
    IF              reduce using rule 55 (term -> identifier .)
    IDENTIFIER      reduce using rule 55 (term -> identifier .)
    INTEGER         reduce using rule 55 (term -> identifier .)
    REAL            reduce using rule 55 (term -> identifier .)
    CHAR            reduce using rule 55 (term -> identifier .)
    STRING          reduce using rule 55 (term -> identifier .)
    FUNCTION        reduce using rule 55 (term -> identifier .)
    ELSE            reduce using rule 55 (term -> identifier .)
    SEMICOLON       reduce using rule 55 (term -> identifier .)
    RPARENARR       reduce using rule 55 (term -> identifier .)
    LPAREN          shift and go to state 94


state 91

    (30) if_else_statement -> IF expression . THEN statement_part
    (31) if_else_statement -> IF expression . THEN statement_part ELSE statement_part
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

    THEN            shift and go to state 110
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    EQ              shift and go to state 80
    NEQ             shift and go to state 81
    GT              shift and go to state 82
    LT              shift and go to state 83
    GTE             shift and go to state 84
    LTE             shift and go to state 85
    AND             shift and go to state 86
    OR              shift and go to state 87

    sign                           shift and go to state 76
    and_or                         shift and go to state 77

state 92

    (35) assignment -> identifier ASSIGNMENT . expression ending
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 90
    expression                     shift and go to state 111
    term                           shift and go to state 48
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 93

    (36) assignment -> identifier LPARENARR . term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 90
    term                           shift and go to state 112
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 94

    (60) function_call -> identifier LPAREN . identifier_list RPAREN
    (67) identifier_list -> . identifier COMMA identifier_list
    (68) identifier_list -> . identifier COMMA identifier
    (69) identifier_list -> . empty
    (75) identifier -> . IDENTIFIER
    (1) empty -> .

    IDENTIFIER      shift and go to state 8
    RPAREN          reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 113
    identifier_list                shift and go to state 114
    empty                          shift and go to state 25

state 95

    (5) block -> declaration_part statement_part .

    BEGIN           reduce using rule 5 (block -> declaration_part statement_part .)
    WHILE           reduce using rule 5 (block -> declaration_part statement_part .)
    IF              reduce using rule 5 (block -> declaration_part statement_part .)
    IDENTIFIER      reduce using rule 5 (block -> declaration_part statement_part .)
    INTEGER         reduce using rule 5 (block -> declaration_part statement_part .)
    REAL            reduce using rule 5 (block -> declaration_part statement_part .)
    CHAR            reduce using rule 5 (block -> declaration_part statement_part .)
    STRING          reduce using rule 5 (block -> declaration_part statement_part .)
    FUNCTION        reduce using rule 5 (block -> declaration_part statement_part .)


state 96

    (4) declaration_part -> type_definition_part variable_declaration_part . function_declaration_part
    (12) function_declaration_part -> . function_declaration function_declaration_part
    (13) function_declaration_part -> . empty
    (14) function_declaration -> . function_heading SEMICOLON block
    (1) empty -> .
    (15) function_heading -> . FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name

  ! shift/reduce conflict for FUNCTION resolved as shift
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    FUNCTION        shift and go to state 20

  ! FUNCTION        [ reduce using rule 1 (empty -> .) ]

    function_declaration_part      shift and go to state 115
    function_declaration           shift and go to state 17
    empty                          shift and go to state 18
    function_heading               shift and go to state 19

state 97

    (18) names_list -> identifier .
    (19) names_list -> identifier . COMMA names_list

    COLON           reduce using rule 18 (names_list -> identifier .)
    COMMA           shift and go to state 116


state 98

    (15) function_heading -> FUNCTION identifier LPAREN parameters . RPAREN COLON simple_type_name

    RPAREN          shift and go to state 117


state 99

    (16) parameters -> names_list . COLON simple_type_name
    (17) parameters -> names_list . COLON simple_type_name SEMICOLON parameters

    COLON           shift and go to state 118


state 100

    (63) variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    COLON           reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    WHILE           reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    IF              reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    INTEGER         reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    REAL            reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    CHAR            reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)
    STRING          reduce using rule 63 (variable_declaration -> identifier_list COLON simple_type_name SEMICOLON .)


state 101

    (65) variable_declaration -> identifier COLON identifier SEMICOLON .

    IDENTIFIER      reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    COLON           reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    FUNCTION        reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    BEGIN           reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    WHILE           reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    IF              reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    INTEGER         reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    REAL            reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    CHAR            reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)
    STRING          reduce using rule 65 (variable_declaration -> identifier COLON identifier SEMICOLON .)


state 102

    (64) variable_declaration -> identifier COLON simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    COLON           reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    WHILE           reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    IF              reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    INTEGER         reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    REAL            reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    CHAR            reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)
    STRING          reduce using rule 64 (variable_declaration -> identifier COLON simple_type_name SEMICOLON .)


state 103

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR . INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 119


state 104

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER . DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    DD              shift and go to state 120


state 105

    (32) compound_statement -> BEGIN statement_part END SEMICOLON .

    $end            reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    END             reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    BEGIN           reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    WHILE           reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    IF              reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    IDENTIFIER      reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    INTEGER         reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    REAL            reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    CHAR            reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    STRING          reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    FUNCTION        reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)
    ELSE            reduce using rule 32 (compound_statement -> BEGIN statement_part END SEMICOLON .)


state 106

    (33) compound_statement -> BEGIN statement_part END DOT .

    $end            reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    END             reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    BEGIN           reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    WHILE           reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    IF              reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    IDENTIFIER      reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    INTEGER         reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    REAL            reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    CHAR            reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    STRING          reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    FUNCTION        reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)
    ELSE            reduce using rule 33 (compound_statement -> BEGIN statement_part END DOT .)


state 107

    (38) expression -> expression sign term .

    PLUS            reduce using rule 38 (expression -> expression sign term .)
    MINUS           reduce using rule 38 (expression -> expression sign term .)
    EQ              reduce using rule 38 (expression -> expression sign term .)
    NEQ             reduce using rule 38 (expression -> expression sign term .)
    GT              reduce using rule 38 (expression -> expression sign term .)
    LT              reduce using rule 38 (expression -> expression sign term .)
    GTE             reduce using rule 38 (expression -> expression sign term .)
    LTE             reduce using rule 38 (expression -> expression sign term .)
    AND             reduce using rule 38 (expression -> expression sign term .)
    OR              reduce using rule 38 (expression -> expression sign term .)
    END             reduce using rule 38 (expression -> expression sign term .)
    BEGIN           reduce using rule 38 (expression -> expression sign term .)
    WHILE           reduce using rule 38 (expression -> expression sign term .)
    IF              reduce using rule 38 (expression -> expression sign term .)
    IDENTIFIER      reduce using rule 38 (expression -> expression sign term .)
    INTEGER         reduce using rule 38 (expression -> expression sign term .)
    REAL            reduce using rule 38 (expression -> expression sign term .)
    CHAR            reduce using rule 38 (expression -> expression sign term .)
    STRING          reduce using rule 38 (expression -> expression sign term .)
    FUNCTION        reduce using rule 38 (expression -> expression sign term .)
    ELSE            reduce using rule 38 (expression -> expression sign term .)
    DO              reduce using rule 38 (expression -> expression sign term .)
    THEN            reduce using rule 38 (expression -> expression sign term .)
    SEMICOLON       reduce using rule 38 (expression -> expression sign term .)


state 108

    (39) expression -> expression and_or expression .
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    END             reduce using rule 39 (expression -> expression and_or expression .)
    BEGIN           reduce using rule 39 (expression -> expression and_or expression .)
    WHILE           reduce using rule 39 (expression -> expression and_or expression .)
    IF              reduce using rule 39 (expression -> expression and_or expression .)
    IDENTIFIER      reduce using rule 39 (expression -> expression and_or expression .)
    INTEGER         reduce using rule 39 (expression -> expression and_or expression .)
    REAL            reduce using rule 39 (expression -> expression and_or expression .)
    CHAR            reduce using rule 39 (expression -> expression and_or expression .)
    STRING          reduce using rule 39 (expression -> expression and_or expression .)
    FUNCTION        reduce using rule 39 (expression -> expression and_or expression .)
    ELSE            reduce using rule 39 (expression -> expression and_or expression .)
    DO              reduce using rule 39 (expression -> expression and_or expression .)
    THEN            reduce using rule 39 (expression -> expression and_or expression .)
    SEMICOLON       reduce using rule 39 (expression -> expression and_or expression .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    EQ              shift and go to state 80
    NEQ             shift and go to state 81
    GT              shift and go to state 82
    LT              shift and go to state 83
    GTE             shift and go to state 84
    LTE             shift and go to state 85
    AND             shift and go to state 86
    OR              shift and go to state 87

  ! PLUS            [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! EQ              [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! NEQ             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! GT              [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! LT              [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! GTE             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! LTE             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! AND             [ reduce using rule 39 (expression -> expression and_or expression .) ]
  ! OR              [ reduce using rule 39 (expression -> expression and_or expression .) ]

    and_or                         shift and go to state 77
    sign                           shift and go to state 76

state 109

    (27) while_statement -> WHILE expression DO . statement_part
    (21) statement_part -> . compound_statement
    (22) statement_part -> . assignment_list
    (23) statement_part -> . while_statement
    (24) statement_part -> . if_else_statement
    (25) statement_part -> . expression
    (26) statement_part -> . empty
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT
    (34) assignment_list -> . assignment statement_part
    (27) while_statement -> . WHILE expression DO statement_part
    (30) if_else_statement -> . IF expression THEN statement_part
    (31) if_else_statement -> . IF expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (35) assignment -> . identifier ASSIGNMENT expression ending
    (36) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 46
    IF              shift and go to state 47
    END             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    expression                     shift and go to state 43
    statement_part                 shift and go to state 121
    compound_statement             shift and go to state 39
    assignment_list                shift and go to state 40
    while_statement                shift and go to state 41
    if_else_statement              shift and go to state 42
    empty                          shift and go to state 44
    assignment                     shift and go to state 45
    term                           shift and go to state 48
    identifier                     shift and go to state 49
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 110

    (30) if_else_statement -> IF expression THEN . statement_part
    (31) if_else_statement -> IF expression THEN . statement_part ELSE statement_part
    (21) statement_part -> . compound_statement
    (22) statement_part -> . assignment_list
    (23) statement_part -> . while_statement
    (24) statement_part -> . if_else_statement
    (25) statement_part -> . expression
    (26) statement_part -> . empty
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT
    (34) assignment_list -> . assignment statement_part
    (27) while_statement -> . WHILE expression DO statement_part
    (30) if_else_statement -> . IF expression THEN statement_part
    (31) if_else_statement -> . IF expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (35) assignment -> . identifier ASSIGNMENT expression ending
    (36) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 46
    IF              shift and go to state 47
    END             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    expression                     shift and go to state 43
    statement_part                 shift and go to state 122
    compound_statement             shift and go to state 39
    assignment_list                shift and go to state 40
    while_statement                shift and go to state 41
    if_else_statement              shift and go to state 42
    empty                          shift and go to state 44
    assignment                     shift and go to state 45
    term                           shift and go to state 48
    identifier                     shift and go to state 49
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 111

    (35) assignment -> identifier ASSIGNMENT expression . ending
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (28) ending -> . SEMICOLON
    (29) ending -> . empty
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR
    (1) empty -> .

    SEMICOLON       shift and go to state 124
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    EQ              shift and go to state 80
    NEQ             shift and go to state 81
    GT              shift and go to state 82
    LT              shift and go to state 83
    GTE             shift and go to state 84
    LTE             shift and go to state 85
    AND             shift and go to state 86
    OR              shift and go to state 87
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    ending                         shift and go to state 123
    sign                           shift and go to state 76
    and_or                         shift and go to state 77
    empty                          shift and go to state 125

state 112

    (36) assignment -> identifier LPARENARR term . RPARENARR ASSIGNMENT expression ending

    RPARENARR       shift and go to state 126


state 113

    (67) identifier_list -> identifier . COMMA identifier_list
    (68) identifier_list -> identifier . COMMA identifier

    COMMA           shift and go to state 36


state 114

    (60) function_call -> identifier LPAREN identifier_list . RPAREN

    RPAREN          shift and go to state 127


state 115

    (4) declaration_part -> type_definition_part variable_declaration_part function_declaration_part .

    BEGIN           reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    WHILE           reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    IF              reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    IDENTIFIER      reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    INTEGER         reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    REAL            reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    CHAR            reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    STRING          reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)
    FUNCTION        reduce using rule 4 (declaration_part -> type_definition_part variable_declaration_part function_declaration_part .)


state 116

    (19) names_list -> identifier COMMA . names_list
    (18) names_list -> . identifier
    (19) names_list -> . identifier COMMA names_list
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 97
    names_list                     shift and go to state 128

state 117

    (15) function_heading -> FUNCTION identifier LPAREN parameters RPAREN . COLON simple_type_name

    COLON           shift and go to state 129


state 118

    (16) parameters -> names_list COLON . simple_type_name
    (17) parameters -> names_list COLON . simple_type_name SEMICOLON parameters
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 64
    SCHAR           shift and go to state 65
    SREAL           shift and go to state 66
    SINTEGER        shift and go to state 67
    IDENTIFIER      shift and go to state 8

    simple_type_name               shift and go to state 130
    identifier                     shift and go to state 68

state 119

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER . DD INTEGER RPARENARR OF simple_type_name SEMICOLON

    DD              shift and go to state 131


state 120

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD . INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 132


state 121

    (27) while_statement -> WHILE expression DO statement_part .

    END             reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    BEGIN           reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    WHILE           reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    IF              reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    IDENTIFIER      reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    INTEGER         reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    REAL            reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    CHAR            reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    STRING          reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    FUNCTION        reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)
    ELSE            reduce using rule 27 (while_statement -> WHILE expression DO statement_part .)


state 122

    (30) if_else_statement -> IF expression THEN statement_part .
    (31) if_else_statement -> IF expression THEN statement_part . ELSE statement_part

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    BEGIN           reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    WHILE           reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    IF              reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    IDENTIFIER      reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    INTEGER         reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    REAL            reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    CHAR            reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    STRING          reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    FUNCTION        reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .)
    ELSE            shift and go to state 133

  ! ELSE            [ reduce using rule 30 (if_else_statement -> IF expression THEN statement_part .) ]


state 123

    (35) assignment -> identifier ASSIGNMENT expression ending .

    BEGIN           reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    WHILE           reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    IF              reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    IDENTIFIER      reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    INTEGER         reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    REAL            reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    CHAR            reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    STRING          reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    END             reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    FUNCTION        reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)
    ELSE            reduce using rule 35 (assignment -> identifier ASSIGNMENT expression ending .)


state 124

    (28) ending -> SEMICOLON .

    BEGIN           reduce using rule 28 (ending -> SEMICOLON .)
    WHILE           reduce using rule 28 (ending -> SEMICOLON .)
    IF              reduce using rule 28 (ending -> SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (ending -> SEMICOLON .)
    INTEGER         reduce using rule 28 (ending -> SEMICOLON .)
    REAL            reduce using rule 28 (ending -> SEMICOLON .)
    CHAR            reduce using rule 28 (ending -> SEMICOLON .)
    STRING          reduce using rule 28 (ending -> SEMICOLON .)
    END             reduce using rule 28 (ending -> SEMICOLON .)
    FUNCTION        reduce using rule 28 (ending -> SEMICOLON .)
    ELSE            reduce using rule 28 (ending -> SEMICOLON .)


state 125

    (29) ending -> empty .

    BEGIN           reduce using rule 29 (ending -> empty .)
    WHILE           reduce using rule 29 (ending -> empty .)
    IF              reduce using rule 29 (ending -> empty .)
    IDENTIFIER      reduce using rule 29 (ending -> empty .)
    INTEGER         reduce using rule 29 (ending -> empty .)
    REAL            reduce using rule 29 (ending -> empty .)
    CHAR            reduce using rule 29 (ending -> empty .)
    STRING          reduce using rule 29 (ending -> empty .)
    END             reduce using rule 29 (ending -> empty .)
    FUNCTION        reduce using rule 29 (ending -> empty .)
    ELSE            reduce using rule 29 (ending -> empty .)


state 126

    (36) assignment -> identifier LPARENARR term RPARENARR . ASSIGNMENT expression ending

    ASSIGNMENT      shift and go to state 134


state 127

    (60) function_call -> identifier LPAREN identifier_list RPAREN .

    PLUS            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    MINUS           reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    EQ              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    NEQ             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    GT              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    LT              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    GTE             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    LTE             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    AND             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    OR              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    END             reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    BEGIN           reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    WHILE           reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    IF              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    IDENTIFIER      reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    INTEGER         reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    REAL            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    CHAR            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    STRING          reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    FUNCTION        reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    ELSE            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    DO              reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    THEN            reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    SEMICOLON       reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)
    RPARENARR       reduce using rule 60 (function_call -> identifier LPAREN identifier_list RPAREN .)


state 128

    (19) names_list -> identifier COMMA names_list .

    COLON           reduce using rule 19 (names_list -> identifier COMMA names_list .)


state 129

    (15) function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON . simple_type_name
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 64
    SCHAR           shift and go to state 65
    SREAL           shift and go to state 66
    SINTEGER        shift and go to state 67
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 68
    simple_type_name               shift and go to state 135

state 130

    (16) parameters -> names_list COLON simple_type_name .
    (17) parameters -> names_list COLON simple_type_name . SEMICOLON parameters

    RPAREN          reduce using rule 16 (parameters -> names_list COLON simple_type_name .)
    SEMICOLON       shift and go to state 136


state 131

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD . INTEGER RPARENARR OF simple_type_name SEMICOLON

    INTEGER         shift and go to state 137


state 132

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER . RPARENARR OF simple_type_name SEMICOLON

    RPARENARR       shift and go to state 138


state 133

    (31) if_else_statement -> IF expression THEN statement_part ELSE . statement_part
    (21) statement_part -> . compound_statement
    (22) statement_part -> . assignment_list
    (23) statement_part -> . while_statement
    (24) statement_part -> . if_else_statement
    (25) statement_part -> . expression
    (26) statement_part -> . empty
    (32) compound_statement -> . BEGIN statement_part END SEMICOLON
    (33) compound_statement -> . BEGIN statement_part END DOT
    (34) assignment_list -> . assignment statement_part
    (27) while_statement -> . WHILE expression DO statement_part
    (30) if_else_statement -> . IF expression THEN statement_part
    (31) if_else_statement -> . IF expression THEN statement_part ELSE statement_part
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (1) empty -> .
    (35) assignment -> . identifier ASSIGNMENT expression ending
    (36) assignment -> . identifier LPARENARR term RPARENARR ASSIGNMENT expression ending
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (75) identifier -> . IDENTIFIER
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    BEGIN           shift and go to state 29
    WHILE           shift and go to state 46
    IF              shift and go to state 47
    END             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 8
    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! WHILE           [ reduce using rule 1 (empty -> .) ]
  ! IF              [ reduce using rule 1 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 1 (empty -> .) ]
  ! INTEGER         [ reduce using rule 1 (empty -> .) ]
  ! REAL            [ reduce using rule 1 (empty -> .) ]
  ! CHAR            [ reduce using rule 1 (empty -> .) ]
  ! STRING          [ reduce using rule 1 (empty -> .) ]

    expression                     shift and go to state 43
    statement_part                 shift and go to state 139
    compound_statement             shift and go to state 39
    assignment_list                shift and go to state 40
    while_statement                shift and go to state 41
    if_else_statement              shift and go to state 42
    empty                          shift and go to state 44
    assignment                     shift and go to state 45
    term                           shift and go to state 48
    identifier                     shift and go to state 49
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 134

    (36) assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT . expression ending
    (37) expression -> . term
    (38) expression -> . expression sign term
    (39) expression -> . expression and_or expression
    (50) term -> . integer
    (51) term -> . real
    (52) term -> . char
    (53) term -> . string
    (54) term -> . function_call
    (55) term -> . identifier
    (56) integer -> . INTEGER
    (57) real -> . REAL
    (59) char -> . CHAR
    (58) string -> . STRING
    (60) function_call -> . identifier LPAREN identifier_list RPAREN
    (75) identifier -> . IDENTIFIER

    INTEGER         shift and go to state 55
    REAL            shift and go to state 56
    CHAR            shift and go to state 57
    STRING          shift and go to state 58
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 90
    term                           shift and go to state 48
    expression                     shift and go to state 140
    integer                        shift and go to state 50
    real                           shift and go to state 51
    char                           shift and go to state 52
    string                         shift and go to state 53
    function_call                  shift and go to state 54

state 135

    (15) function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name .

    SEMICOLON       reduce using rule 15 (function_heading -> FUNCTION identifier LPAREN parameters RPAREN COLON simple_type_name .)


state 136

    (17) parameters -> names_list COLON simple_type_name SEMICOLON . parameters
    (16) parameters -> . names_list COLON simple_type_name
    (17) parameters -> . names_list COLON simple_type_name SEMICOLON parameters
    (18) names_list -> . identifier
    (19) names_list -> . identifier COMMA names_list
    (75) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 8

    names_list                     shift and go to state 99
    parameters                     shift and go to state 141
    identifier                     shift and go to state 97

state 137

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER . RPARENARR OF simple_type_name SEMICOLON

    RPARENARR       shift and go to state 142


state 138

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR . OF simple_type_name SEMICOLON

    OF              shift and go to state 143


state 139

    (31) if_else_statement -> IF expression THEN statement_part ELSE statement_part .

    END             reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    BEGIN           reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    WHILE           reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    IF              reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    IDENTIFIER      reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    INTEGER         reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    REAL            reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    CHAR            reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    STRING          reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    FUNCTION        reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)
    ELSE            reduce using rule 31 (if_else_statement -> IF expression THEN statement_part ELSE statement_part .)


state 140

    (36) assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression . ending
    (38) expression -> expression . sign term
    (39) expression -> expression . and_or expression
    (28) ending -> . SEMICOLON
    (29) ending -> . empty
    (42) sign -> . PLUS
    (43) sign -> . MINUS
    (44) sign -> . EQ
    (45) sign -> . NEQ
    (46) sign -> . GT
    (47) sign -> . LT
    (48) sign -> . GTE
    (49) sign -> . LTE
    (40) and_or -> . AND
    (41) and_or -> . OR
    (1) empty -> .

    SEMICOLON       shift and go to state 124
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    EQ              shift and go to state 80
    NEQ             shift and go to state 81
    GT              shift and go to state 82
    LT              shift and go to state 83
    GTE             shift and go to state 84
    LTE             shift and go to state 85
    AND             shift and go to state 86
    OR              shift and go to state 87
    BEGIN           reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    REAL            reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    ending                         shift and go to state 144
    sign                           shift and go to state 76
    and_or                         shift and go to state 77
    empty                          shift and go to state 125

state 141

    (17) parameters -> names_list COLON simple_type_name SEMICOLON parameters .

    RPAREN          reduce using rule 17 (parameters -> names_list COLON simple_type_name SEMICOLON parameters .)


state 142

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR . OF simple_type_name SEMICOLON

    OF              shift and go to state 145


state 143

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF . simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 64
    SCHAR           shift and go to state 65
    SREAL           shift and go to state 66
    SINTEGER        shift and go to state 67
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 68
    simple_type_name               shift and go to state 146

state 144

    (36) assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .

    BEGIN           reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    WHILE           reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    IF              reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    IDENTIFIER      reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    INTEGER         reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    REAL            reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    CHAR            reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    STRING          reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    END             reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    FUNCTION        reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)
    ELSE            reduce using rule 36 (assignment -> identifier LPARENARR term RPARENARR ASSIGNMENT expression ending .)


state 145

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF . simple_type_name SEMICOLON
    (70) simple_type_name -> . SSTRING
    (71) simple_type_name -> . SCHAR
    (72) simple_type_name -> . SREAL
    (73) simple_type_name -> . SINTEGER
    (74) simple_type_name -> . identifier
    (75) identifier -> . IDENTIFIER

    SSTRING         shift and go to state 64
    SCHAR           shift and go to state 65
    SREAL           shift and go to state 66
    SINTEGER        shift and go to state 67
    IDENTIFIER      shift and go to state 8

    identifier                     shift and go to state 68
    simple_type_name               shift and go to state 147

state 146

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 148


state 147

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name . SEMICOLON

    SEMICOLON       shift and go to state 149


state 148

    (20) type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    VAR             reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    WHILE           reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    IF              reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    INTEGER         reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    REAL            reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    CHAR            reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    STRING          reduce using rule 20 (type_definition -> identifier EQ ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)


state 149

    (66) variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .

    IDENTIFIER      reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    COLON           reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    FUNCTION        reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    BEGIN           reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    WHILE           reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    IF              reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    INTEGER         reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    REAL            reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    CHAR            reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)
    STRING          reduce using rule 66 (variable_declaration -> identifier COLON ARRAY LPARENARR INTEGER DD INTEGER RPARENARR OF simple_type_name SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 13 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 17 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 22 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 45 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 45 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 45 resolved as shift
WARNING: shift/reduce conflict for REAL in state 45 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 45 resolved as shift
WARNING: shift/reduce conflict for STRING in state 45 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 60 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 60 resolved as shift
WARNING: shift/reduce conflict for IF in state 60 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 60 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 60 resolved as shift
WARNING: shift/reduce conflict for REAL in state 60 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 60 resolved as shift
WARNING: shift/reduce conflict for STRING in state 60 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 69 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 96 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for EQ in state 108 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 108 resolved as shift
WARNING: shift/reduce conflict for GT in state 108 resolved as shift
WARNING: shift/reduce conflict for LT in state 108 resolved as shift
WARNING: shift/reduce conflict for GTE in state 108 resolved as shift
WARNING: shift/reduce conflict for LTE in state 108 resolved as shift
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 109 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 109 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 109 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 109 resolved as shift
WARNING: shift/reduce conflict for REAL in state 109 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 109 resolved as shift
WARNING: shift/reduce conflict for STRING in state 109 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 110 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 110 resolved as shift
WARNING: shift/reduce conflict for IF in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 110 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 110 resolved as shift
WARNING: shift/reduce conflict for REAL in state 110 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 110 resolved as shift
WARNING: shift/reduce conflict for STRING in state 110 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 122 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 133 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 133 resolved as shift
WARNING: shift/reduce conflict for IF in state 133 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 133 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 133 resolved as shift
WARNING: shift/reduce conflict for REAL in state 133 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 133 resolved as shift
WARNING: shift/reduce conflict for STRING in state 133 resolved as shift
